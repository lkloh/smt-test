/*********************                                                        */
/** metakind.h
 **
 ** Copyright 2010-2014  New York University and The University of Iowa,
 ** and as below.
 **
 ** This header file automatically generated by:
 **
 **     /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/mkmetakind /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/metakind_template.h /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/booleans/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/uf/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arrays/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/sets/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/strings/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/quantifiers/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/idl/kinds
 **
 ** for the CVC4 project.
 **/

/*********************                                                        */
/*! \file metakind_template.h
 ** \verbatim
 ** Original author: Morgan Deters
 ** Major contributors: none
 ** Minor contributors (to current version): Tim King
 ** This file is part of the CVC4 project.
 ** Copyright (c) 2009-2014  New York University and The University of Iowa
 ** See the file COPYING in the top-level source directory for licensing
 ** information.\endverbatim
 **
 ** \brief Template for the metakind header.
 **
 ** Template for the metakind header.
 **/

#include "cvc4_private.h"

#ifndef __CVC4__KIND__METAKIND_H
#define __CVC4__KIND__METAKIND_H

#include <iostream>

#include "expr/kind.h"
#include "util/cvc4_assert.h"

namespace CVC4 {

namespace expr {
  class NodeValue;
}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

/**
 * Static, compile-time information about types T representing CVC4
 * constants:
 *
 *   typename ConstantMap<T>::OwningTheory
 *
 *     The theory in charge of constructing T when constructing Nodes
 *     with NodeManager::mkConst(T).
 *
 *   typename ConstantMap<T>::kind
 *
 *     The kind to use when constructing Nodes with
 *     NodeManager::mkConst(T).
 */
template <class T>
struct ConstantMap;

/**
 * Static, compile-time information about kinds k and what type their
 * corresponding CVC4 constants are:
 *
 *   typename ConstantMapReverse<k>::T
 *
 *     Constant type for kind k.
 */
template <Kind k>
struct ConstantMapReverse;

/**
 * Static, compile-time mapping from CONSTANT kinds to comparison
 * functors on NodeValue*.  The single element of this structure is:
 *
 *   static bool NodeValueCompare<K, pool>::compare(NodeValue* x, NodeValue* y)
 *
 *     Compares x and y, given that they are both K-kinded (and the
 *     meta-kind of K is CONSTANT).  If pool == true, one of x and y
 *     (but not both) may be a "non-inlined" NodeValue.  If pool ==
 *     false, neither x nor y may be a "non-inlined" NodeValue.
 */
template <Kind k, bool pool>
struct NodeValueConstCompare {
  inline static bool compare(const ::CVC4::expr::NodeValue* x,
                             const ::CVC4::expr::NodeValue* y);
  inline static size_t constHash(const ::CVC4::expr::NodeValue* nv);
};/* NodeValueConstCompare<k, pool> */

struct NodeValueCompare {
  template <bool pool>
  inline static bool compare(const ::CVC4::expr::NodeValue* nv1,
                             const ::CVC4::expr::NodeValue* nv2);
  inline static size_t constHash(const ::CVC4::expr::NodeValue* nv);
};/* struct NodeValueCompare */

/**
 * "metakinds" represent the "kinds" of kinds at the meta-level.
 * "metakind" is an ugly name but it's not used by client code, just
 * by the expr package, and the intent here is to keep it from
 * polluting the kind namespace.  For more documentation on what these
 * mean, see src/theory/builtin/kinds.
 */
enum MetaKind_t {
  INVALID = -1, /**< special node non-kinds like NULL_EXPR or LAST_KIND */
  VARIABLE, /**< special node kinds: no operator */
  OPERATOR, /**< operators that get "inlined" */
  PARAMETERIZED, /**< parameterized ops (like APPLYs) that carry extra data */
  CONSTANT /**< constants */
};/* enum MetaKind_t */

}/* CVC4::kind::metakind namespace */

// import MetaKind into the "CVC4::kind" namespace but keep the
// individual MetaKind constants under kind::metakind::
typedef ::CVC4::kind::metakind::MetaKind_t MetaKind;

/**
 * Get the metakind for a particular kind.
 */
static inline MetaKind metaKindOf(Kind k) {
  static const MetaKind metaKinds[] = {
    metakind::INVALID, /* UNDEFINED_KIND */
    metakind::INVALID, /* NULL_EXPR */

    /* from builtin */
    metakind::VARIABLE, /* SORT_TAG */
    metakind::PARAMETERIZED, /* SORT_TYPE */
    metakind::CONSTANT, /* UNINTERPRETED_CONSTANT */
    metakind::CONSTANT, /* ABSTRACT_VALUE */
    metakind::CONSTANT, /* BUILTIN */
    metakind::VARIABLE, /* FUNCTION */
    metakind::PARAMETERIZED, /* APPLY */
    metakind::OPERATOR, /* EQUAL */
    metakind::OPERATOR, /* DISTINCT */
    metakind::VARIABLE, /* VARIABLE */
    metakind::VARIABLE, /* BOUND_VARIABLE */
    metakind::VARIABLE, /* SKOLEM */
    metakind::OPERATOR, /* SEXPR */
    metakind::OPERATOR, /* LAMBDA */
    metakind::PARAMETERIZED, /* CHAIN */
    metakind::CONSTANT, /* CHAIN_OP */
    metakind::CONSTANT, /* TYPE_CONSTANT */
    metakind::OPERATOR, /* FUNCTION_TYPE */
    metakind::OPERATOR, /* SEXPR_TYPE */
    metakind::CONSTANT, /* SUBTYPE_TYPE */

    /* from booleans */
    metakind::CONSTANT, /* CONST_BOOLEAN */
    metakind::OPERATOR, /* NOT */
    metakind::OPERATOR, /* AND */
    metakind::OPERATOR, /* IFF */
    metakind::OPERATOR, /* IMPLIES */
    metakind::OPERATOR, /* OR */
    metakind::OPERATOR, /* XOR */
    metakind::OPERATOR, /* ITE */

    /* from uf */
    metakind::PARAMETERIZED, /* APPLY_UF */
    metakind::OPERATOR, /* CARDINALITY_CONSTRAINT */
    metakind::OPERATOR, /* COMBINED_CARDINALITY_CONSTRAINT */

    /* from arith */
    metakind::OPERATOR, /* PLUS */
    metakind::OPERATOR, /* MULT */
    metakind::OPERATOR, /* MINUS */
    metakind::OPERATOR, /* UMINUS */
    metakind::OPERATOR, /* DIVISION */
    metakind::OPERATOR, /* DIVISION_TOTAL */
    metakind::OPERATOR, /* INTS_DIVISION */
    metakind::OPERATOR, /* INTS_DIVISION_TOTAL */
    metakind::OPERATOR, /* INTS_MODULUS */
    metakind::OPERATOR, /* INTS_MODULUS_TOTAL */
    metakind::OPERATOR, /* ABS */
    metakind::PARAMETERIZED, /* DIVISIBLE */
    metakind::OPERATOR, /* POW */
    metakind::CONSTANT, /* DIVISIBLE_OP */
    metakind::CONSTANT, /* SUBRANGE_TYPE */
    metakind::CONSTANT, /* CONST_RATIONAL */
    metakind::OPERATOR, /* LT */
    metakind::OPERATOR, /* LEQ */
    metakind::OPERATOR, /* GT */
    metakind::OPERATOR, /* GEQ */
    metakind::OPERATOR, /* IS_INTEGER */
    metakind::OPERATOR, /* TO_INTEGER */
    metakind::OPERATOR, /* TO_REAL */

    /* from bv */
    metakind::CONSTANT, /* BITVECTOR_TYPE */
    metakind::CONSTANT, /* CONST_BITVECTOR */
    metakind::OPERATOR, /* BITVECTOR_CONCAT */
    metakind::OPERATOR, /* BITVECTOR_AND */
    metakind::OPERATOR, /* BITVECTOR_OR */
    metakind::OPERATOR, /* BITVECTOR_XOR */
    metakind::OPERATOR, /* BITVECTOR_NOT */
    metakind::OPERATOR, /* BITVECTOR_NAND */
    metakind::OPERATOR, /* BITVECTOR_NOR */
    metakind::OPERATOR, /* BITVECTOR_XNOR */
    metakind::OPERATOR, /* BITVECTOR_COMP */
    metakind::OPERATOR, /* BITVECTOR_MULT */
    metakind::OPERATOR, /* BITVECTOR_PLUS */
    metakind::OPERATOR, /* BITVECTOR_SUB */
    metakind::OPERATOR, /* BITVECTOR_NEG */
    metakind::OPERATOR, /* BITVECTOR_UDIV */
    metakind::OPERATOR, /* BITVECTOR_UREM */
    metakind::OPERATOR, /* BITVECTOR_SDIV */
    metakind::OPERATOR, /* BITVECTOR_SREM */
    metakind::OPERATOR, /* BITVECTOR_SMOD */
    metakind::OPERATOR, /* BITVECTOR_UDIV_TOTAL */
    metakind::OPERATOR, /* BITVECTOR_UREM_TOTAL */
    metakind::OPERATOR, /* BITVECTOR_SHL */
    metakind::OPERATOR, /* BITVECTOR_LSHR */
    metakind::OPERATOR, /* BITVECTOR_ASHR */
    metakind::OPERATOR, /* BITVECTOR_ULT */
    metakind::OPERATOR, /* BITVECTOR_ULE */
    metakind::OPERATOR, /* BITVECTOR_UGT */
    metakind::OPERATOR, /* BITVECTOR_UGE */
    metakind::OPERATOR, /* BITVECTOR_SLT */
    metakind::OPERATOR, /* BITVECTOR_SLE */
    metakind::OPERATOR, /* BITVECTOR_SGT */
    metakind::OPERATOR, /* BITVECTOR_SGE */
    metakind::OPERATOR, /* BITVECTOR_EAGER_ATOM */
    metakind::OPERATOR, /* BITVECTOR_ACKERMANIZE_UDIV */
    metakind::OPERATOR, /* BITVECTOR_ACKERMANIZE_UREM */
    metakind::CONSTANT, /* BITVECTOR_BITOF_OP */
    metakind::CONSTANT, /* BITVECTOR_EXTRACT_OP */
    metakind::CONSTANT, /* BITVECTOR_REPEAT_OP */
    metakind::CONSTANT, /* BITVECTOR_ZERO_EXTEND_OP */
    metakind::CONSTANT, /* BITVECTOR_SIGN_EXTEND_OP */
    metakind::CONSTANT, /* BITVECTOR_ROTATE_LEFT_OP */
    metakind::CONSTANT, /* BITVECTOR_ROTATE_RIGHT_OP */
    metakind::PARAMETERIZED, /* BITVECTOR_BITOF */
    metakind::PARAMETERIZED, /* BITVECTOR_EXTRACT */
    metakind::PARAMETERIZED, /* BITVECTOR_REPEAT */
    metakind::PARAMETERIZED, /* BITVECTOR_ZERO_EXTEND */
    metakind::PARAMETERIZED, /* BITVECTOR_SIGN_EXTEND */
    metakind::PARAMETERIZED, /* BITVECTOR_ROTATE_LEFT */
    metakind::PARAMETERIZED, /* BITVECTOR_ROTATE_RIGHT */
    metakind::CONSTANT, /* INT_TO_BITVECTOR_OP */
    metakind::PARAMETERIZED, /* INT_TO_BITVECTOR */
    metakind::OPERATOR, /* BITVECTOR_TO_NAT */

    /* from arrays */
    metakind::OPERATOR, /* ARRAY_TYPE */
    metakind::OPERATOR, /* SELECT */
    metakind::OPERATOR, /* STORE */
    metakind::CONSTANT, /* STORE_ALL */
    metakind::OPERATOR, /* ARR_TABLE_FUN */
    metakind::OPERATOR, /* ARRAY_LAMBDA */

    /* from datatypes */
    metakind::OPERATOR, /* CONSTRUCTOR_TYPE */
    metakind::OPERATOR, /* SELECTOR_TYPE */
    metakind::OPERATOR, /* TESTER_TYPE */
    metakind::PARAMETERIZED, /* APPLY_CONSTRUCTOR */
    metakind::PARAMETERIZED, /* APPLY_SELECTOR */
    metakind::PARAMETERIZED, /* APPLY_SELECTOR_TOTAL */
    metakind::PARAMETERIZED, /* APPLY_TESTER */
    metakind::CONSTANT, /* DATATYPE_TYPE */
    metakind::OPERATOR, /* PARAMETRIC_DATATYPE */
    metakind::PARAMETERIZED, /* APPLY_TYPE_ASCRIPTION */
    metakind::CONSTANT, /* ASCRIPTION_TYPE */
    metakind::OPERATOR, /* TUPLE_TYPE */
    metakind::OPERATOR, /* TUPLE */
    metakind::CONSTANT, /* TUPLE_SELECT_OP */
    metakind::PARAMETERIZED, /* TUPLE_SELECT */
    metakind::CONSTANT, /* TUPLE_UPDATE_OP */
    metakind::PARAMETERIZED, /* TUPLE_UPDATE */
    metakind::CONSTANT, /* RECORD_TYPE */
    metakind::PARAMETERIZED, /* RECORD */
    metakind::CONSTANT, /* RECORD_SELECT_OP */
    metakind::PARAMETERIZED, /* RECORD_SELECT */
    metakind::CONSTANT, /* RECORD_UPDATE_OP */
    metakind::PARAMETERIZED, /* RECORD_UPDATE */

    /* from sets */
    metakind::CONSTANT, /* EMPTYSET */
    metakind::OPERATOR, /* SET_TYPE */
    metakind::OPERATOR, /* UNION */
    metakind::OPERATOR, /* INTERSECTION */
    metakind::OPERATOR, /* SETMINUS */
    metakind::OPERATOR, /* SUBSET */
    metakind::OPERATOR, /* MEMBER */
    metakind::OPERATOR, /* SINGLETON */
    metakind::OPERATOR, /* INSERT */

    /* from strings */
    metakind::OPERATOR, /* STRING_CONCAT */
    metakind::OPERATOR, /* STRING_IN_REGEXP */
    metakind::OPERATOR, /* STRING_LENGTH */
    metakind::OPERATOR, /* STRING_SUBSTR */
    metakind::OPERATOR, /* STRING_SUBSTR_TOTAL */
    metakind::OPERATOR, /* STRING_CHARAT */
    metakind::OPERATOR, /* STRING_STRCTN */
    metakind::OPERATOR, /* STRING_STRIDOF */
    metakind::OPERATOR, /* STRING_STRREPL */
    metakind::OPERATOR, /* STRING_PREFIX */
    metakind::OPERATOR, /* STRING_SUFFIX */
    metakind::OPERATOR, /* STRING_ITOS */
    metakind::OPERATOR, /* STRING_STOI */
    metakind::OPERATOR, /* STRING_U16TOS */
    metakind::OPERATOR, /* STRING_STOU16 */
    metakind::OPERATOR, /* STRING_U32TOS */
    metakind::OPERATOR, /* STRING_STOU32 */
    metakind::CONSTANT, /* CONST_STRING */
    metakind::CONSTANT, /* CONST_REGEXP */
    metakind::OPERATOR, /* STRING_TO_REGEXP */
    metakind::OPERATOR, /* REGEXP_CONCAT */
    metakind::OPERATOR, /* REGEXP_UNION */
    metakind::OPERATOR, /* REGEXP_INTER */
    metakind::OPERATOR, /* REGEXP_STAR */
    metakind::OPERATOR, /* REGEXP_PLUS */
    metakind::OPERATOR, /* REGEXP_OPT */
    metakind::OPERATOR, /* REGEXP_RANGE */
    metakind::OPERATOR, /* REGEXP_LOOP */
    metakind::OPERATOR, /* REGEXP_EMPTY */
    metakind::OPERATOR, /* REGEXP_SIGMA */

    /* from quantifiers */
    metakind::OPERATOR, /* FORALL */
    metakind::OPERATOR, /* EXISTS */
    metakind::VARIABLE, /* INST_CONSTANT */
    metakind::OPERATOR, /* BOUND_VAR_LIST */
    metakind::OPERATOR, /* INST_PATTERN */
    metakind::OPERATOR, /* INST_PATTERN_LIST */
    metakind::OPERATOR, /* REWRITE_RULE */
    metakind::OPERATOR, /* RR_REWRITE */
    metakind::OPERATOR, /* RR_REDUCTION */
    metakind::OPERATOR, /* RR_DEDUCTION */

    /* from idl */

    metakind::INVALID /* LAST_KIND */
  };/* metaKinds[] */

  Assert(k >= kind::NULL_EXPR && k < kind::LAST_KIND);

  // We've asserted that k >= NULL_EXPR (which is 0), but we still
  // handle the UNDEFINED_KIND (-1) case.  If we don't, the compiler
  // emits warnings for non-assertion builds, since the check isn't done.
  return metaKinds[k + 1];
}/* metaKindOf(k) */

}/* CVC4::kind namespace */

namespace expr {
  class NodeValue;
}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

/* these are #defines so their sum can be #if-checked in node_value.h */
#define __CVC4__EXPR__NODE_VALUE__NBITS__REFCOUNT 20
#define __CVC4__EXPR__NODE_VALUE__NBITS__KIND 10
#define __CVC4__EXPR__NODE_VALUE__NBITS__ID 40
#define __CVC4__EXPR__NODE_VALUE__NBITS__NCHILDREN 26

static const unsigned MAX_CHILDREN =
  (1u << __CVC4__EXPR__NODE_VALUE__NBITS__NCHILDREN) - 1;

}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// Comparison predicate
struct NodeValueEq {
  inline bool operator()(const NodeValue* nv1, const NodeValue* nv2) const {
    return ::CVC4::kind::metakind::NodeValueCompare::compare<false>(nv1, nv2);
  }
};

// Comparison predicate
struct NodeValuePoolEq {
  inline bool operator()(const NodeValue* nv1, const NodeValue* nv2) const {
    return ::CVC4::kind::metakind::NodeValueCompare::compare<true>(nv1, nv2);
  }
};

}/* CVC4::expr namespace */
}/* CVC4 namespace */

#include "expr/node_value.h"

#endif /* __CVC4__KIND__METAKIND_H */


// #include "theory/builtin/::CVC4::theory::builtin::TheoryBuiltin"
#include "util/uninterpreted_constant.h"
#include "util/abstract_value.h"
#include "expr/kind.h"
#include "util/chain.h"
#include "expr/kind.h"
#include "util/predicate.h"
// #include "theory/booleans/::CVC4::theory::booleans::TheoryBool"
#include "util/bool.h"
// #include "theory/uf/::CVC4::theory::uf::TheoryUF"
// #include "theory/arith/::CVC4::theory::arith::TheoryArith"
#include "util/divisible.h"
#include "util/subrange_bound.h"
#include "util/rational.h"
// #include "theory/bv/::CVC4::theory::bv::TheoryBV"
#include "util/bitvector.h"
#include "util/bitvector.h"
#include "util/bitvector.h"
#include "util/bitvector.h"
#include "util/bitvector.h"
#include "util/bitvector.h"
#include "util/bitvector.h"
#include "util/bitvector.h"
#include "util/bitvector.h"
#include "util/bitvector.h"
// #include "theory/arrays/::CVC4::theory::arrays::TheoryArrays"
#include "util/array_store_all.h"
// #include "theory/datatypes/::CVC4::theory::datatypes::TheoryDatatypes"
#include "util/datatype.h"
#include "util/ascription_type.h"
#include "util/tuple.h"
#include "util/tuple.h"
#include "util/record.h"
#include "util/record.h"
#include "util/record.h"
// #include "theory/sets/::CVC4::theory::sets::TheorySets"
#include "util/emptyset.h"
// #include "theory/strings/::CVC4::theory::strings::TheoryStrings"
#include "util/regexp.h"
#include "util/regexp.h"
// #include "theory/quantifiers/::CVC4::theory::quantifiers::TheoryQuantifiers"

#ifdef __CVC4__NODE_MANAGER_NEEDS_CONSTANT_MAP

namespace CVC4 {
namespace kind {
namespace metakind {

template <Kind k, bool pool>
inline bool NodeValueConstCompare<k, pool>::compare(const ::CVC4::expr::NodeValue* x,
                                                    const ::CVC4::expr::NodeValue* y) {
  typedef typename ConstantMapReverse<k>::T T;
  if(pool) {
    if(x->d_nchildren == 1) {
      Assert(y->d_nchildren == 0);
      return compare(y, x);
    } else if(y->d_nchildren == 1) {
      Assert(x->d_nchildren == 0);
      return x->getConst<T>() == *reinterpret_cast<T*>(y->d_children[0]);
    }
  }

  Assert(x->d_nchildren == 0);
  Assert(y->d_nchildren == 0);
  return x->getConst<T>() == y->getConst<T>();
}

template <Kind k, bool pool>
inline size_t NodeValueConstCompare<k, pool>::constHash(const ::CVC4::expr::NodeValue* nv) {
  typedef typename ConstantMapReverse<k>::T T;
  return nv->getConst<T>().hash();
}


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::UninterpretedConstant const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::UninterpretedConstant const& NodeValue::getConst< ::CVC4::UninterpretedConstant >() const {
  AssertArgument(getKind() == ::CVC4::kind::UNINTERPRETED_CONSTANT, *this,
                 "Improper kind for getConst<::CVC4::UninterpretedConstant>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::UninterpretedConstant const* >(d_children)
    : *reinterpret_cast< ::CVC4::UninterpretedConstant const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::UninterpretedConstant > {
  // typedef THEORY_BUILTIN OwningTheory;
  enum { kind = ::CVC4::kind::UNINTERPRETED_CONSTANT };
};/* ConstantMap< ::CVC4::UninterpretedConstant > */

template <>
struct ConstantMapReverse< ::CVC4::kind::UNINTERPRETED_CONSTANT > {
  typedef ::CVC4::UninterpretedConstant T;
};/* ConstantMapReverse< ::CVC4::kind::UNINTERPRETED_CONSTANT > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::AbstractValue const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::AbstractValue const& NodeValue::getConst< ::CVC4::AbstractValue >() const {
  AssertArgument(getKind() == ::CVC4::kind::ABSTRACT_VALUE, *this,
                 "Improper kind for getConst<::CVC4::AbstractValue>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::AbstractValue const* >(d_children)
    : *reinterpret_cast< ::CVC4::AbstractValue const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::AbstractValue > {
  // typedef THEORY_BUILTIN OwningTheory;
  enum { kind = ::CVC4::kind::ABSTRACT_VALUE };
};/* ConstantMap< ::CVC4::AbstractValue > */

template <>
struct ConstantMapReverse< ::CVC4::kind::ABSTRACT_VALUE > {
  typedef ::CVC4::AbstractValue T;
};/* ConstantMapReverse< ::CVC4::kind::ABSTRACT_VALUE > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::Kind const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::Kind const& NodeValue::getConst< ::CVC4::Kind >() const {
  AssertArgument(getKind() == ::CVC4::kind::BUILTIN, *this,
                 "Improper kind for getConst<::CVC4::Kind>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::Kind const* >(d_children)
    : *reinterpret_cast< ::CVC4::Kind const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::Kind > {
  // typedef THEORY_BUILTIN OwningTheory;
  enum { kind = ::CVC4::kind::BUILTIN };
};/* ConstantMap< ::CVC4::Kind > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BUILTIN > {
  typedef ::CVC4::Kind T;
};/* ConstantMapReverse< ::CVC4::kind::BUILTIN > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::Chain const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::Chain const& NodeValue::getConst< ::CVC4::Chain >() const {
  AssertArgument(getKind() == ::CVC4::kind::CHAIN_OP, *this,
                 "Improper kind for getConst<::CVC4::Chain>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::Chain const* >(d_children)
    : *reinterpret_cast< ::CVC4::Chain const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::Chain > {
  // typedef THEORY_BUILTIN OwningTheory;
  enum { kind = ::CVC4::kind::CHAIN_OP };
};/* ConstantMap< ::CVC4::Chain > */

template <>
struct ConstantMapReverse< ::CVC4::kind::CHAIN_OP > {
  typedef ::CVC4::Chain T;
};/* ConstantMapReverse< ::CVC4::kind::CHAIN_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::TypeConstant const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::TypeConstant const& NodeValue::getConst< ::CVC4::TypeConstant >() const {
  AssertArgument(getKind() == ::CVC4::kind::TYPE_CONSTANT, *this,
                 "Improper kind for getConst<::CVC4::TypeConstant>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::TypeConstant const* >(d_children)
    : *reinterpret_cast< ::CVC4::TypeConstant const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::TypeConstant > {
  // typedef THEORY_BUILTIN OwningTheory;
  enum { kind = ::CVC4::kind::TYPE_CONSTANT };
};/* ConstantMap< ::CVC4::TypeConstant > */

template <>
struct ConstantMapReverse< ::CVC4::kind::TYPE_CONSTANT > {
  typedef ::CVC4::TypeConstant T;
};/* ConstantMapReverse< ::CVC4::kind::TYPE_CONSTANT > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::Predicate const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::Predicate const& NodeValue::getConst< ::CVC4::Predicate >() const {
  AssertArgument(getKind() == ::CVC4::kind::SUBTYPE_TYPE, *this,
                 "Improper kind for getConst<::CVC4::Predicate>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::Predicate const* >(d_children)
    : *reinterpret_cast< ::CVC4::Predicate const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::Predicate > {
  // typedef THEORY_BUILTIN OwningTheory;
  enum { kind = ::CVC4::kind::SUBTYPE_TYPE };
};/* ConstantMap< ::CVC4::Predicate > */

template <>
struct ConstantMapReverse< ::CVC4::kind::SUBTYPE_TYPE > {
  typedef ::CVC4::Predicate T;
};/* ConstantMapReverse< ::CVC4::kind::SUBTYPE_TYPE > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "bool const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline bool const& NodeValue::getConst< bool >() const {
  AssertArgument(getKind() == ::CVC4::kind::CONST_BOOLEAN, *this,
                 "Improper kind for getConst<bool>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< bool const* >(d_children)
    : *reinterpret_cast< bool const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< bool > {
  // typedef THEORY_BOOL OwningTheory;
  enum { kind = ::CVC4::kind::CONST_BOOLEAN };
};/* ConstantMap< bool > */

template <>
struct ConstantMapReverse< ::CVC4::kind::CONST_BOOLEAN > {
  typedef bool T;
};/* ConstantMapReverse< ::CVC4::kind::CONST_BOOLEAN > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::Divisible const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::Divisible const& NodeValue::getConst< ::CVC4::Divisible >() const {
  AssertArgument(getKind() == ::CVC4::kind::DIVISIBLE_OP, *this,
                 "Improper kind for getConst<::CVC4::Divisible>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::Divisible const* >(d_children)
    : *reinterpret_cast< ::CVC4::Divisible const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::Divisible > {
  // typedef THEORY_ARITH OwningTheory;
  enum { kind = ::CVC4::kind::DIVISIBLE_OP };
};/* ConstantMap< ::CVC4::Divisible > */

template <>
struct ConstantMapReverse< ::CVC4::kind::DIVISIBLE_OP > {
  typedef ::CVC4::Divisible T;
};/* ConstantMapReverse< ::CVC4::kind::DIVISIBLE_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::SubrangeBounds const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::SubrangeBounds const& NodeValue::getConst< ::CVC4::SubrangeBounds >() const {
  AssertArgument(getKind() == ::CVC4::kind::SUBRANGE_TYPE, *this,
                 "Improper kind for getConst<::CVC4::SubrangeBounds>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::SubrangeBounds const* >(d_children)
    : *reinterpret_cast< ::CVC4::SubrangeBounds const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::SubrangeBounds > {
  // typedef THEORY_ARITH OwningTheory;
  enum { kind = ::CVC4::kind::SUBRANGE_TYPE };
};/* ConstantMap< ::CVC4::SubrangeBounds > */

template <>
struct ConstantMapReverse< ::CVC4::kind::SUBRANGE_TYPE > {
  typedef ::CVC4::SubrangeBounds T;
};/* ConstantMapReverse< ::CVC4::kind::SUBRANGE_TYPE > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::Rational const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::Rational const& NodeValue::getConst< ::CVC4::Rational >() const {
  AssertArgument(getKind() == ::CVC4::kind::CONST_RATIONAL, *this,
                 "Improper kind for getConst<::CVC4::Rational>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::Rational const* >(d_children)
    : *reinterpret_cast< ::CVC4::Rational const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::Rational > {
  // typedef THEORY_ARITH OwningTheory;
  enum { kind = ::CVC4::kind::CONST_RATIONAL };
};/* ConstantMap< ::CVC4::Rational > */

template <>
struct ConstantMapReverse< ::CVC4::kind::CONST_RATIONAL > {
  typedef ::CVC4::Rational T;
};/* ConstantMapReverse< ::CVC4::kind::CONST_RATIONAL > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVectorSize const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVectorSize const& NodeValue::getConst< ::CVC4::BitVectorSize >() const {
  AssertArgument(getKind() == ::CVC4::kind::BITVECTOR_TYPE, *this,
                 "Improper kind for getConst<::CVC4::BitVectorSize>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVectorSize const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVectorSize const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVectorSize > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::BITVECTOR_TYPE };
};/* ConstantMap< ::CVC4::BitVectorSize > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BITVECTOR_TYPE > {
  typedef ::CVC4::BitVectorSize T;
};/* ConstantMapReverse< ::CVC4::kind::BITVECTOR_TYPE > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVector const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVector const& NodeValue::getConst< ::CVC4::BitVector >() const {
  AssertArgument(getKind() == ::CVC4::kind::CONST_BITVECTOR, *this,
                 "Improper kind for getConst<::CVC4::BitVector>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVector const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVector const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVector > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::CONST_BITVECTOR };
};/* ConstantMap< ::CVC4::BitVector > */

template <>
struct ConstantMapReverse< ::CVC4::kind::CONST_BITVECTOR > {
  typedef ::CVC4::BitVector T;
};/* ConstantMapReverse< ::CVC4::kind::CONST_BITVECTOR > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVectorBitOf const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVectorBitOf const& NodeValue::getConst< ::CVC4::BitVectorBitOf >() const {
  AssertArgument(getKind() == ::CVC4::kind::BITVECTOR_BITOF_OP, *this,
                 "Improper kind for getConst<::CVC4::BitVectorBitOf>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVectorBitOf const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVectorBitOf const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVectorBitOf > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::BITVECTOR_BITOF_OP };
};/* ConstantMap< ::CVC4::BitVectorBitOf > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BITVECTOR_BITOF_OP > {
  typedef ::CVC4::BitVectorBitOf T;
};/* ConstantMapReverse< ::CVC4::kind::BITVECTOR_BITOF_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVectorExtract const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVectorExtract const& NodeValue::getConst< ::CVC4::BitVectorExtract >() const {
  AssertArgument(getKind() == ::CVC4::kind::BITVECTOR_EXTRACT_OP, *this,
                 "Improper kind for getConst<::CVC4::BitVectorExtract>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVectorExtract const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVectorExtract const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVectorExtract > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::BITVECTOR_EXTRACT_OP };
};/* ConstantMap< ::CVC4::BitVectorExtract > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BITVECTOR_EXTRACT_OP > {
  typedef ::CVC4::BitVectorExtract T;
};/* ConstantMapReverse< ::CVC4::kind::BITVECTOR_EXTRACT_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVectorRepeat const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVectorRepeat const& NodeValue::getConst< ::CVC4::BitVectorRepeat >() const {
  AssertArgument(getKind() == ::CVC4::kind::BITVECTOR_REPEAT_OP, *this,
                 "Improper kind for getConst<::CVC4::BitVectorRepeat>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVectorRepeat const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVectorRepeat const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVectorRepeat > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::BITVECTOR_REPEAT_OP };
};/* ConstantMap< ::CVC4::BitVectorRepeat > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BITVECTOR_REPEAT_OP > {
  typedef ::CVC4::BitVectorRepeat T;
};/* ConstantMapReverse< ::CVC4::kind::BITVECTOR_REPEAT_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVectorZeroExtend const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVectorZeroExtend const& NodeValue::getConst< ::CVC4::BitVectorZeroExtend >() const {
  AssertArgument(getKind() == ::CVC4::kind::BITVECTOR_ZERO_EXTEND_OP, *this,
                 "Improper kind for getConst<::CVC4::BitVectorZeroExtend>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVectorZeroExtend const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVectorZeroExtend const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVectorZeroExtend > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::BITVECTOR_ZERO_EXTEND_OP };
};/* ConstantMap< ::CVC4::BitVectorZeroExtend > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BITVECTOR_ZERO_EXTEND_OP > {
  typedef ::CVC4::BitVectorZeroExtend T;
};/* ConstantMapReverse< ::CVC4::kind::BITVECTOR_ZERO_EXTEND_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVectorSignExtend const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVectorSignExtend const& NodeValue::getConst< ::CVC4::BitVectorSignExtend >() const {
  AssertArgument(getKind() == ::CVC4::kind::BITVECTOR_SIGN_EXTEND_OP, *this,
                 "Improper kind for getConst<::CVC4::BitVectorSignExtend>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVectorSignExtend const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVectorSignExtend const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVectorSignExtend > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::BITVECTOR_SIGN_EXTEND_OP };
};/* ConstantMap< ::CVC4::BitVectorSignExtend > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BITVECTOR_SIGN_EXTEND_OP > {
  typedef ::CVC4::BitVectorSignExtend T;
};/* ConstantMapReverse< ::CVC4::kind::BITVECTOR_SIGN_EXTEND_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVectorRotateLeft const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVectorRotateLeft const& NodeValue::getConst< ::CVC4::BitVectorRotateLeft >() const {
  AssertArgument(getKind() == ::CVC4::kind::BITVECTOR_ROTATE_LEFT_OP, *this,
                 "Improper kind for getConst<::CVC4::BitVectorRotateLeft>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVectorRotateLeft const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVectorRotateLeft const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVectorRotateLeft > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::BITVECTOR_ROTATE_LEFT_OP };
};/* ConstantMap< ::CVC4::BitVectorRotateLeft > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BITVECTOR_ROTATE_LEFT_OP > {
  typedef ::CVC4::BitVectorRotateLeft T;
};/* ConstantMapReverse< ::CVC4::kind::BITVECTOR_ROTATE_LEFT_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::BitVectorRotateRight const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::BitVectorRotateRight const& NodeValue::getConst< ::CVC4::BitVectorRotateRight >() const {
  AssertArgument(getKind() == ::CVC4::kind::BITVECTOR_ROTATE_RIGHT_OP, *this,
                 "Improper kind for getConst<::CVC4::BitVectorRotateRight>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::BitVectorRotateRight const* >(d_children)
    : *reinterpret_cast< ::CVC4::BitVectorRotateRight const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::BitVectorRotateRight > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::BITVECTOR_ROTATE_RIGHT_OP };
};/* ConstantMap< ::CVC4::BitVectorRotateRight > */

template <>
struct ConstantMapReverse< ::CVC4::kind::BITVECTOR_ROTATE_RIGHT_OP > {
  typedef ::CVC4::BitVectorRotateRight T;
};/* ConstantMapReverse< ::CVC4::kind::BITVECTOR_ROTATE_RIGHT_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::IntToBitVector const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::IntToBitVector const& NodeValue::getConst< ::CVC4::IntToBitVector >() const {
  AssertArgument(getKind() == ::CVC4::kind::INT_TO_BITVECTOR_OP, *this,
                 "Improper kind for getConst<::CVC4::IntToBitVector>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::IntToBitVector const* >(d_children)
    : *reinterpret_cast< ::CVC4::IntToBitVector const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::IntToBitVector > {
  // typedef THEORY_BV OwningTheory;
  enum { kind = ::CVC4::kind::INT_TO_BITVECTOR_OP };
};/* ConstantMap< ::CVC4::IntToBitVector > */

template <>
struct ConstantMapReverse< ::CVC4::kind::INT_TO_BITVECTOR_OP > {
  typedef ::CVC4::IntToBitVector T;
};/* ConstantMapReverse< ::CVC4::kind::INT_TO_BITVECTOR_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::ArrayStoreAll const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::ArrayStoreAll const& NodeValue::getConst< ::CVC4::ArrayStoreAll >() const {
  AssertArgument(getKind() == ::CVC4::kind::STORE_ALL, *this,
                 "Improper kind for getConst<::CVC4::ArrayStoreAll>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::ArrayStoreAll const* >(d_children)
    : *reinterpret_cast< ::CVC4::ArrayStoreAll const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::ArrayStoreAll > {
  // typedef THEORY_ARRAY OwningTheory;
  enum { kind = ::CVC4::kind::STORE_ALL };
};/* ConstantMap< ::CVC4::ArrayStoreAll > */

template <>
struct ConstantMapReverse< ::CVC4::kind::STORE_ALL > {
  typedef ::CVC4::ArrayStoreAll T;
};/* ConstantMapReverse< ::CVC4::kind::STORE_ALL > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::Datatype const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::Datatype const& NodeValue::getConst< ::CVC4::Datatype >() const {
  AssertArgument(getKind() == ::CVC4::kind::DATATYPE_TYPE, *this,
                 "Improper kind for getConst<::CVC4::Datatype>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::Datatype const* >(d_children)
    : *reinterpret_cast< ::CVC4::Datatype const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::Datatype > {
  // typedef THEORY_DATATYPES OwningTheory;
  enum { kind = ::CVC4::kind::DATATYPE_TYPE };
};/* ConstantMap< ::CVC4::Datatype > */

template <>
struct ConstantMapReverse< ::CVC4::kind::DATATYPE_TYPE > {
  typedef ::CVC4::Datatype T;
};/* ConstantMapReverse< ::CVC4::kind::DATATYPE_TYPE > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::AscriptionType const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::AscriptionType const& NodeValue::getConst< ::CVC4::AscriptionType >() const {
  AssertArgument(getKind() == ::CVC4::kind::ASCRIPTION_TYPE, *this,
                 "Improper kind for getConst<::CVC4::AscriptionType>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::AscriptionType const* >(d_children)
    : *reinterpret_cast< ::CVC4::AscriptionType const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::AscriptionType > {
  // typedef THEORY_DATATYPES OwningTheory;
  enum { kind = ::CVC4::kind::ASCRIPTION_TYPE };
};/* ConstantMap< ::CVC4::AscriptionType > */

template <>
struct ConstantMapReverse< ::CVC4::kind::ASCRIPTION_TYPE > {
  typedef ::CVC4::AscriptionType T;
};/* ConstantMapReverse< ::CVC4::kind::ASCRIPTION_TYPE > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::TupleSelect const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::TupleSelect const& NodeValue::getConst< ::CVC4::TupleSelect >() const {
  AssertArgument(getKind() == ::CVC4::kind::TUPLE_SELECT_OP, *this,
                 "Improper kind for getConst<::CVC4::TupleSelect>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::TupleSelect const* >(d_children)
    : *reinterpret_cast< ::CVC4::TupleSelect const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::TupleSelect > {
  // typedef THEORY_DATATYPES OwningTheory;
  enum { kind = ::CVC4::kind::TUPLE_SELECT_OP };
};/* ConstantMap< ::CVC4::TupleSelect > */

template <>
struct ConstantMapReverse< ::CVC4::kind::TUPLE_SELECT_OP > {
  typedef ::CVC4::TupleSelect T;
};/* ConstantMapReverse< ::CVC4::kind::TUPLE_SELECT_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::TupleUpdate const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::TupleUpdate const& NodeValue::getConst< ::CVC4::TupleUpdate >() const {
  AssertArgument(getKind() == ::CVC4::kind::TUPLE_UPDATE_OP, *this,
                 "Improper kind for getConst<::CVC4::TupleUpdate>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::TupleUpdate const* >(d_children)
    : *reinterpret_cast< ::CVC4::TupleUpdate const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::TupleUpdate > {
  // typedef THEORY_DATATYPES OwningTheory;
  enum { kind = ::CVC4::kind::TUPLE_UPDATE_OP };
};/* ConstantMap< ::CVC4::TupleUpdate > */

template <>
struct ConstantMapReverse< ::CVC4::kind::TUPLE_UPDATE_OP > {
  typedef ::CVC4::TupleUpdate T;
};/* ConstantMapReverse< ::CVC4::kind::TUPLE_UPDATE_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::Record const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::Record const& NodeValue::getConst< ::CVC4::Record >() const {
  AssertArgument(getKind() == ::CVC4::kind::RECORD_TYPE, *this,
                 "Improper kind for getConst<::CVC4::Record>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::Record const* >(d_children)
    : *reinterpret_cast< ::CVC4::Record const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::Record > {
  // typedef THEORY_DATATYPES OwningTheory;
  enum { kind = ::CVC4::kind::RECORD_TYPE };
};/* ConstantMap< ::CVC4::Record > */

template <>
struct ConstantMapReverse< ::CVC4::kind::RECORD_TYPE > {
  typedef ::CVC4::Record T;
};/* ConstantMapReverse< ::CVC4::kind::RECORD_TYPE > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::RecordSelect const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::RecordSelect const& NodeValue::getConst< ::CVC4::RecordSelect >() const {
  AssertArgument(getKind() == ::CVC4::kind::RECORD_SELECT_OP, *this,
                 "Improper kind for getConst<::CVC4::RecordSelect>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::RecordSelect const* >(d_children)
    : *reinterpret_cast< ::CVC4::RecordSelect const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::RecordSelect > {
  // typedef THEORY_DATATYPES OwningTheory;
  enum { kind = ::CVC4::kind::RECORD_SELECT_OP };
};/* ConstantMap< ::CVC4::RecordSelect > */

template <>
struct ConstantMapReverse< ::CVC4::kind::RECORD_SELECT_OP > {
  typedef ::CVC4::RecordSelect T;
};/* ConstantMapReverse< ::CVC4::kind::RECORD_SELECT_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::RecordUpdate const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::RecordUpdate const& NodeValue::getConst< ::CVC4::RecordUpdate >() const {
  AssertArgument(getKind() == ::CVC4::kind::RECORD_UPDATE_OP, *this,
                 "Improper kind for getConst<::CVC4::RecordUpdate>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::RecordUpdate const* >(d_children)
    : *reinterpret_cast< ::CVC4::RecordUpdate const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::RecordUpdate > {
  // typedef THEORY_DATATYPES OwningTheory;
  enum { kind = ::CVC4::kind::RECORD_UPDATE_OP };
};/* ConstantMap< ::CVC4::RecordUpdate > */

template <>
struct ConstantMapReverse< ::CVC4::kind::RECORD_UPDATE_OP > {
  typedef ::CVC4::RecordUpdate T;
};/* ConstantMapReverse< ::CVC4::kind::RECORD_UPDATE_OP > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::EmptySet const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::EmptySet const& NodeValue::getConst< ::CVC4::EmptySet >() const {
  AssertArgument(getKind() == ::CVC4::kind::EMPTYSET, *this,
                 "Improper kind for getConst<::CVC4::EmptySet>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::EmptySet const* >(d_children)
    : *reinterpret_cast< ::CVC4::EmptySet const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::EmptySet > {
  // typedef THEORY_SETS OwningTheory;
  enum { kind = ::CVC4::kind::EMPTYSET };
};/* ConstantMap< ::CVC4::EmptySet > */

template <>
struct ConstantMapReverse< ::CVC4::kind::EMPTYSET > {
  typedef ::CVC4::EmptySet T;
};/* ConstantMapReverse< ::CVC4::kind::EMPTYSET > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::String const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::String const& NodeValue::getConst< ::CVC4::String >() const {
  AssertArgument(getKind() == ::CVC4::kind::CONST_STRING, *this,
                 "Improper kind for getConst<::CVC4::String>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::String const* >(d_children)
    : *reinterpret_cast< ::CVC4::String const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::String > {
  // typedef THEORY_STRINGS OwningTheory;
  enum { kind = ::CVC4::kind::CONST_STRING };
};/* ConstantMap< ::CVC4::String > */

template <>
struct ConstantMapReverse< ::CVC4::kind::CONST_STRING > {
  typedef ::CVC4::String T;
};/* ConstantMapReverse< ::CVC4::kind::CONST_STRING > */


}/* CVC4::kind::metakind namespace */
}/* CVC4::kind namespace */

namespace expr {

// The reinterpret_cast of d_children to "::CVC4::RegExp const*"
// flags a "strict aliasing" warning; it's okay, because we never access
// the embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

template <>
inline ::CVC4::RegExp const& NodeValue::getConst< ::CVC4::RegExp >() const {
  AssertArgument(getKind() == ::CVC4::kind::CONST_REGEXP, *this,
                 "Improper kind for getConst<::CVC4::RegExp>()");
  // To support non-inlined CONSTANT-kinded NodeValues (those that are
  // "constructed" when initially checking them against the NodeManager
  // pool), we must check d_nchildren here.
  return d_nchildren == 0
    ? *reinterpret_cast< ::CVC4::RegExp const* >(d_children)
    : *reinterpret_cast< ::CVC4::RegExp const* >(d_children[0]);
}

// re-enable the warning
#pragma GCC diagnostic warning "-Wstrict-aliasing"

}/* CVC4::expr namespace */

namespace kind {
namespace metakind {

template <>
struct ConstantMap< ::CVC4::RegExp > {
  // typedef THEORY_STRINGS OwningTheory;
  enum { kind = ::CVC4::kind::CONST_REGEXP };
};/* ConstantMap< ::CVC4::RegExp > */

template <>
struct ConstantMapReverse< ::CVC4::kind::CONST_REGEXP > {
  typedef ::CVC4::RegExp T;
};/* ConstantMapReverse< ::CVC4::kind::CONST_REGEXP > */



template <bool pool>
inline bool NodeValueCompare::compare(const ::CVC4::expr::NodeValue* nv1,
                                      const ::CVC4::expr::NodeValue* nv2) {
  if(nv1->d_kind != nv2->d_kind) {
    return false;
  }

  if(nv1->getMetaKind() == kind::metakind::CONSTANT) {
    switch(nv1->d_kind) {

    case kind::UNINTERPRETED_CONSTANT:
      return NodeValueConstCompare< kind::UNINTERPRETED_CONSTANT, pool >::compare(nv1, nv2);

    case kind::ABSTRACT_VALUE:
      return NodeValueConstCompare< kind::ABSTRACT_VALUE, pool >::compare(nv1, nv2);

    case kind::BUILTIN:
      return NodeValueConstCompare< kind::BUILTIN, pool >::compare(nv1, nv2);

    case kind::CHAIN_OP:
      return NodeValueConstCompare< kind::CHAIN_OP, pool >::compare(nv1, nv2);

    case kind::TYPE_CONSTANT:
      return NodeValueConstCompare< kind::TYPE_CONSTANT, pool >::compare(nv1, nv2);

    case kind::SUBTYPE_TYPE:
      return NodeValueConstCompare< kind::SUBTYPE_TYPE, pool >::compare(nv1, nv2);

    case kind::CONST_BOOLEAN:
      return NodeValueConstCompare< kind::CONST_BOOLEAN, pool >::compare(nv1, nv2);

    case kind::DIVISIBLE_OP:
      return NodeValueConstCompare< kind::DIVISIBLE_OP, pool >::compare(nv1, nv2);

    case kind::SUBRANGE_TYPE:
      return NodeValueConstCompare< kind::SUBRANGE_TYPE, pool >::compare(nv1, nv2);

    case kind::CONST_RATIONAL:
      return NodeValueConstCompare< kind::CONST_RATIONAL, pool >::compare(nv1, nv2);

    case kind::BITVECTOR_TYPE:
      return NodeValueConstCompare< kind::BITVECTOR_TYPE, pool >::compare(nv1, nv2);

    case kind::CONST_BITVECTOR:
      return NodeValueConstCompare< kind::CONST_BITVECTOR, pool >::compare(nv1, nv2);

    case kind::BITVECTOR_BITOF_OP:
      return NodeValueConstCompare< kind::BITVECTOR_BITOF_OP, pool >::compare(nv1, nv2);

    case kind::BITVECTOR_EXTRACT_OP:
      return NodeValueConstCompare< kind::BITVECTOR_EXTRACT_OP, pool >::compare(nv1, nv2);

    case kind::BITVECTOR_REPEAT_OP:
      return NodeValueConstCompare< kind::BITVECTOR_REPEAT_OP, pool >::compare(nv1, nv2);

    case kind::BITVECTOR_ZERO_EXTEND_OP:
      return NodeValueConstCompare< kind::BITVECTOR_ZERO_EXTEND_OP, pool >::compare(nv1, nv2);

    case kind::BITVECTOR_SIGN_EXTEND_OP:
      return NodeValueConstCompare< kind::BITVECTOR_SIGN_EXTEND_OP, pool >::compare(nv1, nv2);

    case kind::BITVECTOR_ROTATE_LEFT_OP:
      return NodeValueConstCompare< kind::BITVECTOR_ROTATE_LEFT_OP, pool >::compare(nv1, nv2);

    case kind::BITVECTOR_ROTATE_RIGHT_OP:
      return NodeValueConstCompare< kind::BITVECTOR_ROTATE_RIGHT_OP, pool >::compare(nv1, nv2);

    case kind::INT_TO_BITVECTOR_OP:
      return NodeValueConstCompare< kind::INT_TO_BITVECTOR_OP, pool >::compare(nv1, nv2);

    case kind::STORE_ALL:
      return NodeValueConstCompare< kind::STORE_ALL, pool >::compare(nv1, nv2);

    case kind::DATATYPE_TYPE:
      return NodeValueConstCompare< kind::DATATYPE_TYPE, pool >::compare(nv1, nv2);

    case kind::ASCRIPTION_TYPE:
      return NodeValueConstCompare< kind::ASCRIPTION_TYPE, pool >::compare(nv1, nv2);

    case kind::TUPLE_SELECT_OP:
      return NodeValueConstCompare< kind::TUPLE_SELECT_OP, pool >::compare(nv1, nv2);

    case kind::TUPLE_UPDATE_OP:
      return NodeValueConstCompare< kind::TUPLE_UPDATE_OP, pool >::compare(nv1, nv2);

    case kind::RECORD_TYPE:
      return NodeValueConstCompare< kind::RECORD_TYPE, pool >::compare(nv1, nv2);

    case kind::RECORD_SELECT_OP:
      return NodeValueConstCompare< kind::RECORD_SELECT_OP, pool >::compare(nv1, nv2);

    case kind::RECORD_UPDATE_OP:
      return NodeValueConstCompare< kind::RECORD_UPDATE_OP, pool >::compare(nv1, nv2);

    case kind::EMPTYSET:
      return NodeValueConstCompare< kind::EMPTYSET, pool >::compare(nv1, nv2);

    case kind::CONST_STRING:
      return NodeValueConstCompare< kind::CONST_STRING, pool >::compare(nv1, nv2);

    case kind::CONST_REGEXP:
      return NodeValueConstCompare< kind::CONST_REGEXP, pool >::compare(nv1, nv2);

    default:
      Unhandled(::CVC4::expr::NodeValue::dKindToKind(nv1->d_kind));
    }
  }

  if(nv1->d_nchildren != nv2->d_nchildren) {
    return false;
  }

  ::CVC4::expr::NodeValue::const_nv_iterator i = nv1->nv_begin();
  ::CVC4::expr::NodeValue::const_nv_iterator j = nv2->nv_begin();
  ::CVC4::expr::NodeValue::const_nv_iterator i_end = nv1->nv_end();

  while(i != i_end) {
    if((*i) != (*j)) {
      return false;
    }
    ++i;
    ++j;
  }

  return true;
}

inline size_t NodeValueCompare::constHash(const ::CVC4::expr::NodeValue* nv) {
  Assert(nv->getMetaKind() == kind::metakind::CONSTANT);

  switch(nv->d_kind) {

  case kind::UNINTERPRETED_CONSTANT:
#line 266 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    return ::CVC4::UninterpretedConstantHashFunction()(nv->getConst< ::CVC4::UninterpretedConstant >());

  case kind::ABSTRACT_VALUE:
#line 276 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    return ::CVC4::AbstractValueHashFunction()(nv->getConst< ::CVC4::AbstractValue >());

  case kind::BUILTIN:
#line 287 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    return ::CVC4::kind::KindHashFunction()(nv->getConst< ::CVC4::Kind >());

  case kind::CHAIN_OP:
#line 309 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    return ::CVC4::ChainHashFunction()(nv->getConst< ::CVC4::Chain >());

  case kind::TYPE_CONSTANT:
#line 315 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    return ::CVC4::TypeConstantHashFunction()(nv->getConst< ::CVC4::TypeConstant >());

  case kind::SUBTYPE_TYPE:
#line 343 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    return ::CVC4::PredicateHashFunction()(nv->getConst< ::CVC4::Predicate >());

  case kind::CONST_BOOLEAN:
#line 21 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/booleans/kinds"
    return ::CVC4::BoolHashFunction()(nv->getConst< bool >());

  case kind::DIVISIBLE_OP:
#line 29 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    return ::CVC4::DivisibleHashFunction()(nv->getConst< ::CVC4::Divisible >());

  case kind::SUBRANGE_TYPE:
#line 48 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    return ::CVC4::SubrangeBoundsHashFunction()(nv->getConst< ::CVC4::SubrangeBounds >());

  case kind::CONST_RATIONAL:
#line 61 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    return ::CVC4::RationalHashFunction()(nv->getConst< ::CVC4::Rational >());

  case kind::BITVECTOR_TYPE:
#line 15 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::UnsignedHashFunction< ::CVC4::BitVectorSize >()(nv->getConst< ::CVC4::BitVectorSize >());

  case kind::CONST_BITVECTOR:
#line 24 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::BitVectorHashFunction()(nv->getConst< ::CVC4::BitVector >());

  case kind::BITVECTOR_BITOF_OP:
#line 77 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::BitVectorBitOfHashFunction()(nv->getConst< ::CVC4::BitVectorBitOf >());

  case kind::BITVECTOR_EXTRACT_OP:
#line 83 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::BitVectorExtractHashFunction()(nv->getConst< ::CVC4::BitVectorExtract >());

  case kind::BITVECTOR_REPEAT_OP:
#line 89 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::UnsignedHashFunction< ::CVC4::BitVectorRepeat >()(nv->getConst< ::CVC4::BitVectorRepeat >());

  case kind::BITVECTOR_ZERO_EXTEND_OP:
#line 95 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::UnsignedHashFunction< ::CVC4::BitVectorZeroExtend >()(nv->getConst< ::CVC4::BitVectorZeroExtend >());

  case kind::BITVECTOR_SIGN_EXTEND_OP:
#line 101 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::UnsignedHashFunction< ::CVC4::BitVectorSignExtend >()(nv->getConst< ::CVC4::BitVectorSignExtend >());

  case kind::BITVECTOR_ROTATE_LEFT_OP:
#line 107 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::UnsignedHashFunction< ::CVC4::BitVectorRotateLeft >()(nv->getConst< ::CVC4::BitVectorRotateLeft >());

  case kind::BITVECTOR_ROTATE_RIGHT_OP:
#line 113 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::UnsignedHashFunction< ::CVC4::BitVectorRotateRight >()(nv->getConst< ::CVC4::BitVectorRotateRight >());

  case kind::INT_TO_BITVECTOR_OP:
#line 127 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    return ::CVC4::UnsignedHashFunction< ::CVC4::IntToBitVector >()(nv->getConst< ::CVC4::IntToBitVector >());

  case kind::STORE_ALL:
#line 35 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arrays/kinds"
    return ::CVC4::ArrayStoreAllHashFunction()(nv->getConst< ::CVC4::ArrayStoreAll >());

  case kind::DATATYPE_TYPE:
#line 45 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    return ::CVC4::DatatypeHashFunction()(nv->getConst< ::CVC4::Datatype >());

  case kind::ASCRIPTION_TYPE:
#line 77 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    return ::CVC4::AscriptionTypeHashFunction()(nv->getConst< ::CVC4::AscriptionType >());

  case kind::TUPLE_SELECT_OP:
#line 108 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    return ::CVC4::TupleSelectHashFunction()(nv->getConst< ::CVC4::TupleSelect >());

  case kind::TUPLE_UPDATE_OP:
#line 116 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    return ::CVC4::TupleUpdateHashFunction()(nv->getConst< ::CVC4::TupleUpdate >());

  case kind::RECORD_TYPE:
#line 124 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    return ::CVC4::RecordHashFunction()(nv->getConst< ::CVC4::Record >());

  case kind::RECORD_SELECT_OP:
#line 144 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    return ::CVC4::RecordSelectHashFunction()(nv->getConst< ::CVC4::RecordSelect >());

  case kind::RECORD_UPDATE_OP:
#line 152 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    return ::CVC4::RecordUpdateHashFunction()(nv->getConst< ::CVC4::RecordUpdate >());

  case kind::EMPTYSET:
#line 18 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/sets/kinds"
    return ::CVC4::EmptySetHashFunction()(nv->getConst< ::CVC4::EmptySet >());

  case kind::CONST_STRING:
#line 62 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/strings/kinds"
    return ::CVC4::strings::StringHashFunction()(nv->getConst< ::CVC4::String >());

  case kind::CONST_REGEXP:
#line 68 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/strings/kinds"
    return ::CVC4::RegExpHashFunction()(nv->getConst< ::CVC4::RegExp >());

  default:
    Unhandled(::CVC4::expr::NodeValue::dKindToKind(nv->d_kind));
  }
}

struct NodeValueConstPrinter {
  inline static void toStream(std::ostream& out,
                              const ::CVC4::expr::NodeValue* nv);
  inline static void toStream(std::ostream& out, TNode n);
};

inline void NodeValueConstPrinter::toStream(std::ostream& out,
                                            const ::CVC4::expr::NodeValue* nv) {
  Assert(nv->getMetaKind() == kind::metakind::CONSTANT);

  switch(nv->d_kind) {

  case kind::UNINTERPRETED_CONSTANT:
#line 266 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    out << nv->getConst< ::CVC4::UninterpretedConstant >();
    break;

  case kind::ABSTRACT_VALUE:
#line 276 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    out << nv->getConst< ::CVC4::AbstractValue >();
    break;

  case kind::BUILTIN:
#line 287 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    out << nv->getConst< ::CVC4::Kind >();
    break;

  case kind::CHAIN_OP:
#line 309 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    out << nv->getConst< ::CVC4::Chain >();
    break;

  case kind::TYPE_CONSTANT:
#line 315 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    out << nv->getConst< ::CVC4::TypeConstant >();
    break;

  case kind::SUBTYPE_TYPE:
#line 343 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    out << nv->getConst< ::CVC4::Predicate >();
    break;

  case kind::CONST_BOOLEAN:
#line 21 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/booleans/kinds"
    out << nv->getConst< bool >();
    break;

  case kind::DIVISIBLE_OP:
#line 29 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    out << nv->getConst< ::CVC4::Divisible >();
    break;

  case kind::SUBRANGE_TYPE:
#line 48 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    out << nv->getConst< ::CVC4::SubrangeBounds >();
    break;

  case kind::CONST_RATIONAL:
#line 61 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    out << nv->getConst< ::CVC4::Rational >();
    break;

  case kind::BITVECTOR_TYPE:
#line 15 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVectorSize >();
    break;

  case kind::CONST_BITVECTOR:
#line 24 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVector >();
    break;

  case kind::BITVECTOR_BITOF_OP:
#line 77 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVectorBitOf >();
    break;

  case kind::BITVECTOR_EXTRACT_OP:
#line 83 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVectorExtract >();
    break;

  case kind::BITVECTOR_REPEAT_OP:
#line 89 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVectorRepeat >();
    break;

  case kind::BITVECTOR_ZERO_EXTEND_OP:
#line 95 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVectorZeroExtend >();
    break;

  case kind::BITVECTOR_SIGN_EXTEND_OP:
#line 101 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVectorSignExtend >();
    break;

  case kind::BITVECTOR_ROTATE_LEFT_OP:
#line 107 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVectorRotateLeft >();
    break;

  case kind::BITVECTOR_ROTATE_RIGHT_OP:
#line 113 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::BitVectorRotateRight >();
    break;

  case kind::INT_TO_BITVECTOR_OP:
#line 127 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    out << nv->getConst< ::CVC4::IntToBitVector >();
    break;

  case kind::STORE_ALL:
#line 35 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arrays/kinds"
    out << nv->getConst< ::CVC4::ArrayStoreAll >();
    break;

  case kind::DATATYPE_TYPE:
#line 45 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    out << nv->getConst< ::CVC4::Datatype >();
    break;

  case kind::ASCRIPTION_TYPE:
#line 77 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    out << nv->getConst< ::CVC4::AscriptionType >();
    break;

  case kind::TUPLE_SELECT_OP:
#line 108 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    out << nv->getConst< ::CVC4::TupleSelect >();
    break;

  case kind::TUPLE_UPDATE_OP:
#line 116 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    out << nv->getConst< ::CVC4::TupleUpdate >();
    break;

  case kind::RECORD_TYPE:
#line 124 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    out << nv->getConst< ::CVC4::Record >();
    break;

  case kind::RECORD_SELECT_OP:
#line 144 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    out << nv->getConst< ::CVC4::RecordSelect >();
    break;

  case kind::RECORD_UPDATE_OP:
#line 152 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    out << nv->getConst< ::CVC4::RecordUpdate >();
    break;

  case kind::EMPTYSET:
#line 18 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/sets/kinds"
    out << nv->getConst< ::CVC4::EmptySet >();
    break;

  case kind::CONST_STRING:
#line 62 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/strings/kinds"
    out << nv->getConst< ::CVC4::String >();
    break;

  case kind::CONST_REGEXP:
#line 68 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/strings/kinds"
    out << nv->getConst< ::CVC4::RegExp >();
    break;

  default:
    Unhandled(::CVC4::expr::NodeValue::dKindToKind(nv->d_kind));
  }
}

inline void NodeValueConstPrinter::toStream(std::ostream& out, TNode n) {
  toStream(out, n.d_nv);
}

// The reinterpret_cast of d_children to various constant payload types
// in deleteNodeValueConstant(), below, can flag a "strict aliasing"
// warning; it should actually be okay, because we never access the
// embedded constant as a NodeValue* child, and never access an embedded
// NodeValue* child as a constant.
#pragma GCC diagnostic ignored "-Wstrict-aliasing"

/**
 * Cleanup to be performed when a NodeValue zombie is collected, and
 * it has CONSTANT metakind.  This calls the destructor for the underlying
 * C++ type representing the constant value.  See
 * NodeManager::reclaimZombies() for more information.
 *
 * This doesn't support "non-inlined" NodeValues, which shouldn't need this
 * kind of cleanup.
 */
inline void deleteNodeValueConstant(::CVC4::expr::NodeValue* nv) {
  Assert(nv->getMetaKind() == kind::metakind::CONSTANT);

  switch(nv->d_kind) {

  case kind::UNINTERPRETED_CONSTANT:
#line 266 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    std::allocator< ::CVC4::UninterpretedConstant >().destroy(reinterpret_cast< ::CVC4::UninterpretedConstant* >(nv->d_children));
    break;

  case kind::ABSTRACT_VALUE:
#line 276 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    std::allocator< ::CVC4::AbstractValue >().destroy(reinterpret_cast< ::CVC4::AbstractValue* >(nv->d_children));
    break;

  case kind::BUILTIN:
#line 287 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    std::allocator< ::CVC4::Kind >().destroy(reinterpret_cast< ::CVC4::Kind* >(nv->d_children));
    break;

  case kind::CHAIN_OP:
#line 309 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    std::allocator< ::CVC4::Chain >().destroy(reinterpret_cast< ::CVC4::Chain* >(nv->d_children));
    break;

  case kind::TYPE_CONSTANT:
#line 315 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    std::allocator< ::CVC4::TypeConstant >().destroy(reinterpret_cast< ::CVC4::TypeConstant* >(nv->d_children));
    break;

  case kind::SUBTYPE_TYPE:
#line 343 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    std::allocator< ::CVC4::Predicate >().destroy(reinterpret_cast< ::CVC4::Predicate* >(nv->d_children));
    break;

  case kind::CONST_BOOLEAN:
#line 21 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/booleans/kinds"
    std::allocator< bool >().destroy(reinterpret_cast< bool* >(nv->d_children));
    break;

  case kind::DIVISIBLE_OP:
#line 29 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    std::allocator< ::CVC4::Divisible >().destroy(reinterpret_cast< ::CVC4::Divisible* >(nv->d_children));
    break;

  case kind::SUBRANGE_TYPE:
#line 48 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    std::allocator< ::CVC4::SubrangeBounds >().destroy(reinterpret_cast< ::CVC4::SubrangeBounds* >(nv->d_children));
    break;

  case kind::CONST_RATIONAL:
#line 61 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    std::allocator< ::CVC4::Rational >().destroy(reinterpret_cast< ::CVC4::Rational* >(nv->d_children));
    break;

  case kind::BITVECTOR_TYPE:
#line 15 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVectorSize >().destroy(reinterpret_cast< ::CVC4::BitVectorSize* >(nv->d_children));
    break;

  case kind::CONST_BITVECTOR:
#line 24 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVector >().destroy(reinterpret_cast< ::CVC4::BitVector* >(nv->d_children));
    break;

  case kind::BITVECTOR_BITOF_OP:
#line 77 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVectorBitOf >().destroy(reinterpret_cast< ::CVC4::BitVectorBitOf* >(nv->d_children));
    break;

  case kind::BITVECTOR_EXTRACT_OP:
#line 83 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVectorExtract >().destroy(reinterpret_cast< ::CVC4::BitVectorExtract* >(nv->d_children));
    break;

  case kind::BITVECTOR_REPEAT_OP:
#line 89 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVectorRepeat >().destroy(reinterpret_cast< ::CVC4::BitVectorRepeat* >(nv->d_children));
    break;

  case kind::BITVECTOR_ZERO_EXTEND_OP:
#line 95 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVectorZeroExtend >().destroy(reinterpret_cast< ::CVC4::BitVectorZeroExtend* >(nv->d_children));
    break;

  case kind::BITVECTOR_SIGN_EXTEND_OP:
#line 101 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVectorSignExtend >().destroy(reinterpret_cast< ::CVC4::BitVectorSignExtend* >(nv->d_children));
    break;

  case kind::BITVECTOR_ROTATE_LEFT_OP:
#line 107 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVectorRotateLeft >().destroy(reinterpret_cast< ::CVC4::BitVectorRotateLeft* >(nv->d_children));
    break;

  case kind::BITVECTOR_ROTATE_RIGHT_OP:
#line 113 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::BitVectorRotateRight >().destroy(reinterpret_cast< ::CVC4::BitVectorRotateRight* >(nv->d_children));
    break;

  case kind::INT_TO_BITVECTOR_OP:
#line 127 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    std::allocator< ::CVC4::IntToBitVector >().destroy(reinterpret_cast< ::CVC4::IntToBitVector* >(nv->d_children));
    break;

  case kind::STORE_ALL:
#line 35 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arrays/kinds"
    std::allocator< ::CVC4::ArrayStoreAll >().destroy(reinterpret_cast< ::CVC4::ArrayStoreAll* >(nv->d_children));
    break;

  case kind::DATATYPE_TYPE:
#line 45 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    std::allocator< ::CVC4::Datatype >().destroy(reinterpret_cast< ::CVC4::Datatype* >(nv->d_children));
    break;

  case kind::ASCRIPTION_TYPE:
#line 77 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    std::allocator< ::CVC4::AscriptionType >().destroy(reinterpret_cast< ::CVC4::AscriptionType* >(nv->d_children));
    break;

  case kind::TUPLE_SELECT_OP:
#line 108 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    std::allocator< ::CVC4::TupleSelect >().destroy(reinterpret_cast< ::CVC4::TupleSelect* >(nv->d_children));
    break;

  case kind::TUPLE_UPDATE_OP:
#line 116 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    std::allocator< ::CVC4::TupleUpdate >().destroy(reinterpret_cast< ::CVC4::TupleUpdate* >(nv->d_children));
    break;

  case kind::RECORD_TYPE:
#line 124 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    std::allocator< ::CVC4::Record >().destroy(reinterpret_cast< ::CVC4::Record* >(nv->d_children));
    break;

  case kind::RECORD_SELECT_OP:
#line 144 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    std::allocator< ::CVC4::RecordSelect >().destroy(reinterpret_cast< ::CVC4::RecordSelect* >(nv->d_children));
    break;

  case kind::RECORD_UPDATE_OP:
#line 152 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    std::allocator< ::CVC4::RecordUpdate >().destroy(reinterpret_cast< ::CVC4::RecordUpdate* >(nv->d_children));
    break;

  case kind::EMPTYSET:
#line 18 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/sets/kinds"
    std::allocator< ::CVC4::EmptySet >().destroy(reinterpret_cast< ::CVC4::EmptySet* >(nv->d_children));
    break;

  case kind::CONST_STRING:
#line 62 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/strings/kinds"
    std::allocator< ::CVC4::String >().destroy(reinterpret_cast< ::CVC4::String* >(nv->d_children));
    break;

  case kind::CONST_REGEXP:
#line 68 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/strings/kinds"
    std::allocator< ::CVC4::RegExp >().destroy(reinterpret_cast< ::CVC4::RegExp* >(nv->d_children));
    break;

  default:
    Unhandled(::CVC4::expr::NodeValue::dKindToKind(nv->d_kind));
  }
}

// re-enable the strict-aliasing warning
# pragma GCC diagnostic warning "-Wstrict-aliasing"

inline unsigned getLowerBoundForKind(::CVC4::Kind k) {
  static const unsigned lbs[] = {
    0, /* NULL_EXPR */

    0, /* SORT_TAG */
    0, /* SORT_TYPE */
    0, /* UNINTERPRETED_CONSTANT */
    0, /* ABSTRACT_VALUE */
    0, /* BUILTIN */
    0, /* FUNCTION */
    0, /* APPLY */
    2, /* EQUAL */
    2, /* DISTINCT */
    0, /* VARIABLE */
    0, /* BOUND_VARIABLE */
    0, /* SKOLEM */
    0, /* SEXPR */
    2, /* LAMBDA */
    2, /* CHAIN */
    0, /* CHAIN_OP */
    0, /* TYPE_CONSTANT */
    2, /* FUNCTION_TYPE */
    0, /* SEXPR_TYPE */
    0, /* SUBTYPE_TYPE */
    0, /* CONST_BOOLEAN */
    1, /* NOT */
    2, /* AND */
    2, /* IFF */
    2, /* IMPLIES */
    2, /* OR */
    2, /* XOR */
    3, /* ITE */
    1, /* APPLY_UF */
    2, /* CARDINALITY_CONSTRAINT */
    1, /* COMBINED_CARDINALITY_CONSTRAINT */
    2, /* PLUS */
    2, /* MULT */
    2, /* MINUS */
    1, /* UMINUS */
    2, /* DIVISION */
    2, /* DIVISION_TOTAL */
    2, /* INTS_DIVISION */
    2, /* INTS_DIVISION_TOTAL */
    2, /* INTS_MODULUS */
    2, /* INTS_MODULUS_TOTAL */
    1, /* ABS */
    1, /* DIVISIBLE */
    2, /* POW */
    0, /* DIVISIBLE_OP */
    0, /* SUBRANGE_TYPE */
    0, /* CONST_RATIONAL */
    2, /* LT */
    2, /* LEQ */
    2, /* GT */
    2, /* GEQ */
    1, /* IS_INTEGER */
    1, /* TO_INTEGER */
    1, /* TO_REAL */
    0, /* BITVECTOR_TYPE */
    0, /* CONST_BITVECTOR */
    2, /* BITVECTOR_CONCAT */
    2, /* BITVECTOR_AND */
    2, /* BITVECTOR_OR */
    2, /* BITVECTOR_XOR */
    1, /* BITVECTOR_NOT */
    2, /* BITVECTOR_NAND */
    2, /* BITVECTOR_NOR */
    2, /* BITVECTOR_XNOR */
    2, /* BITVECTOR_COMP */
    2, /* BITVECTOR_MULT */
    2, /* BITVECTOR_PLUS */
    2, /* BITVECTOR_SUB */
    1, /* BITVECTOR_NEG */
    2, /* BITVECTOR_UDIV */
    2, /* BITVECTOR_UREM */
    2, /* BITVECTOR_SDIV */
    2, /* BITVECTOR_SREM */
    2, /* BITVECTOR_SMOD */
    2, /* BITVECTOR_UDIV_TOTAL */
    2, /* BITVECTOR_UREM_TOTAL */
    2, /* BITVECTOR_SHL */
    2, /* BITVECTOR_LSHR */
    2, /* BITVECTOR_ASHR */
    2, /* BITVECTOR_ULT */
    2, /* BITVECTOR_ULE */
    2, /* BITVECTOR_UGT */
    2, /* BITVECTOR_UGE */
    2, /* BITVECTOR_SLT */
    2, /* BITVECTOR_SLE */
    2, /* BITVECTOR_SGT */
    2, /* BITVECTOR_SGE */
    1, /* BITVECTOR_EAGER_ATOM */
    1, /* BITVECTOR_ACKERMANIZE_UDIV */
    1, /* BITVECTOR_ACKERMANIZE_UREM */
    0, /* BITVECTOR_BITOF_OP */
    0, /* BITVECTOR_EXTRACT_OP */
    0, /* BITVECTOR_REPEAT_OP */
    0, /* BITVECTOR_ZERO_EXTEND_OP */
    0, /* BITVECTOR_SIGN_EXTEND_OP */
    0, /* BITVECTOR_ROTATE_LEFT_OP */
    0, /* BITVECTOR_ROTATE_RIGHT_OP */
    1, /* BITVECTOR_BITOF */
    1, /* BITVECTOR_EXTRACT */
    1, /* BITVECTOR_REPEAT */
    1, /* BITVECTOR_ZERO_EXTEND */
    1, /* BITVECTOR_SIGN_EXTEND */
    1, /* BITVECTOR_ROTATE_LEFT */
    1, /* BITVECTOR_ROTATE_RIGHT */
    0, /* INT_TO_BITVECTOR_OP */
    1, /* INT_TO_BITVECTOR */
    1, /* BITVECTOR_TO_NAT */
    2, /* ARRAY_TYPE */
    2, /* SELECT */
    3, /* STORE */
    0, /* STORE_ALL */
    4, /* ARR_TABLE_FUN */
    1, /* ARRAY_LAMBDA */
    1, /* CONSTRUCTOR_TYPE */
    2, /* SELECTOR_TYPE */
    1, /* TESTER_TYPE */
    0, /* APPLY_CONSTRUCTOR */
    1, /* APPLY_SELECTOR */
    1, /* APPLY_SELECTOR_TOTAL */
    1, /* APPLY_TESTER */
    0, /* DATATYPE_TYPE */
    1, /* PARAMETRIC_DATATYPE */
    1, /* APPLY_TYPE_ASCRIPTION */
    0, /* ASCRIPTION_TYPE */
    0, /* TUPLE_TYPE */
    0, /* TUPLE */
    0, /* TUPLE_SELECT_OP */
    1, /* TUPLE_SELECT */
    0, /* TUPLE_UPDATE_OP */
    2, /* TUPLE_UPDATE */
    0, /* RECORD_TYPE */
    0, /* RECORD */
    0, /* RECORD_SELECT_OP */
    1, /* RECORD_SELECT */
    0, /* RECORD_UPDATE_OP */
    2, /* RECORD_UPDATE */
    0, /* EMPTYSET */
    1, /* SET_TYPE */
    2, /* UNION */
    2, /* INTERSECTION */
    2, /* SETMINUS */
    2, /* SUBSET */
    2, /* MEMBER */
    1, /* SINGLETON */
    2, /* INSERT */
    2, /* STRING_CONCAT */
    2, /* STRING_IN_REGEXP */
    1, /* STRING_LENGTH */
    3, /* STRING_SUBSTR */
    3, /* STRING_SUBSTR_TOTAL */
    2, /* STRING_CHARAT */
    2, /* STRING_STRCTN */
    3, /* STRING_STRIDOF */
    3, /* STRING_STRREPL */
    2, /* STRING_PREFIX */
    2, /* STRING_SUFFIX */
    1, /* STRING_ITOS */
    1, /* STRING_STOI */
    1, /* STRING_U16TOS */
    1, /* STRING_STOU16 */
    1, /* STRING_U32TOS */
    1, /* STRING_STOU32 */
    0, /* CONST_STRING */
    0, /* CONST_REGEXP */
    1, /* STRING_TO_REGEXP */
    2, /* REGEXP_CONCAT */
    2, /* REGEXP_UNION */
    2, /* REGEXP_INTER */
    1, /* REGEXP_STAR */
    1, /* REGEXP_PLUS */
    1, /* REGEXP_OPT */
    2, /* REGEXP_RANGE */
    2, /* REGEXP_LOOP */
    0, /* REGEXP_EMPTY */
    0, /* REGEXP_SIGMA */
    2, /* FORALL */
    2, /* EXISTS */
    0, /* INST_CONSTANT */
    1, /* BOUND_VAR_LIST */
    1, /* INST_PATTERN */
    1, /* INST_PATTERN_LIST */
    3, /* REWRITE_RULE */
    2, /* RR_REWRITE */
    2, /* RR_REDUCTION */
    2, /* RR_DEDUCTION */

    0 /* LAST_KIND */
  };

  return lbs[k];
}

inline unsigned getUpperBoundForKind(::CVC4::Kind k) {
  static const unsigned ubs[] = {
    0, /* NULL_EXPR */

    0, /* SORT_TAG */
    MAX_CHILDREN, /* SORT_TYPE */
    0, /* UNINTERPRETED_CONSTANT */
    0, /* ABSTRACT_VALUE */
    0, /* BUILTIN */
    0, /* FUNCTION */
    MAX_CHILDREN, /* APPLY */
    2, /* EQUAL */
    MAX_CHILDREN, /* DISTINCT */
    0, /* VARIABLE */
    0, /* BOUND_VARIABLE */
    0, /* SKOLEM */
    MAX_CHILDREN, /* SEXPR */
    2, /* LAMBDA */
    MAX_CHILDREN, /* CHAIN */
    0, /* CHAIN_OP */
    0, /* TYPE_CONSTANT */
    MAX_CHILDREN, /* FUNCTION_TYPE */
    MAX_CHILDREN, /* SEXPR_TYPE */
    0, /* SUBTYPE_TYPE */
    0, /* CONST_BOOLEAN */
    1, /* NOT */
    MAX_CHILDREN, /* AND */
    2, /* IFF */
    2, /* IMPLIES */
    MAX_CHILDREN, /* OR */
    2, /* XOR */
    3, /* ITE */
    MAX_CHILDREN, /* APPLY_UF */
    2, /* CARDINALITY_CONSTRAINT */
    1, /* COMBINED_CARDINALITY_CONSTRAINT */
    MAX_CHILDREN, /* PLUS */
    MAX_CHILDREN, /* MULT */
    2, /* MINUS */
    1, /* UMINUS */
    2, /* DIVISION */
    2, /* DIVISION_TOTAL */
    2, /* INTS_DIVISION */
    2, /* INTS_DIVISION_TOTAL */
    2, /* INTS_MODULUS */
    2, /* INTS_MODULUS_TOTAL */
    1, /* ABS */
    1, /* DIVISIBLE */
    2, /* POW */
    0, /* DIVISIBLE_OP */
    0, /* SUBRANGE_TYPE */
    0, /* CONST_RATIONAL */
    2, /* LT */
    2, /* LEQ */
    2, /* GT */
    2, /* GEQ */
    1, /* IS_INTEGER */
    1, /* TO_INTEGER */
    1, /* TO_REAL */
    0, /* BITVECTOR_TYPE */
    0, /* CONST_BITVECTOR */
    MAX_CHILDREN, /* BITVECTOR_CONCAT */
    MAX_CHILDREN, /* BITVECTOR_AND */
    MAX_CHILDREN, /* BITVECTOR_OR */
    MAX_CHILDREN, /* BITVECTOR_XOR */
    1, /* BITVECTOR_NOT */
    2, /* BITVECTOR_NAND */
    2, /* BITVECTOR_NOR */
    2, /* BITVECTOR_XNOR */
    2, /* BITVECTOR_COMP */
    MAX_CHILDREN, /* BITVECTOR_MULT */
    MAX_CHILDREN, /* BITVECTOR_PLUS */
    2, /* BITVECTOR_SUB */
    1, /* BITVECTOR_NEG */
    2, /* BITVECTOR_UDIV */
    2, /* BITVECTOR_UREM */
    2, /* BITVECTOR_SDIV */
    2, /* BITVECTOR_SREM */
    2, /* BITVECTOR_SMOD */
    2, /* BITVECTOR_UDIV_TOTAL */
    2, /* BITVECTOR_UREM_TOTAL */
    2, /* BITVECTOR_SHL */
    2, /* BITVECTOR_LSHR */
    2, /* BITVECTOR_ASHR */
    2, /* BITVECTOR_ULT */
    2, /* BITVECTOR_ULE */
    2, /* BITVECTOR_UGT */
    2, /* BITVECTOR_UGE */
    2, /* BITVECTOR_SLT */
    2, /* BITVECTOR_SLE */
    2, /* BITVECTOR_SGT */
    2, /* BITVECTOR_SGE */
    1, /* BITVECTOR_EAGER_ATOM */
    1, /* BITVECTOR_ACKERMANIZE_UDIV */
    1, /* BITVECTOR_ACKERMANIZE_UREM */
    0, /* BITVECTOR_BITOF_OP */
    0, /* BITVECTOR_EXTRACT_OP */
    0, /* BITVECTOR_REPEAT_OP */
    0, /* BITVECTOR_ZERO_EXTEND_OP */
    0, /* BITVECTOR_SIGN_EXTEND_OP */
    0, /* BITVECTOR_ROTATE_LEFT_OP */
    0, /* BITVECTOR_ROTATE_RIGHT_OP */
    1, /* BITVECTOR_BITOF */
    1, /* BITVECTOR_EXTRACT */
    1, /* BITVECTOR_REPEAT */
    1, /* BITVECTOR_ZERO_EXTEND */
    1, /* BITVECTOR_SIGN_EXTEND */
    1, /* BITVECTOR_ROTATE_LEFT */
    1, /* BITVECTOR_ROTATE_RIGHT */
    0, /* INT_TO_BITVECTOR_OP */
    1, /* INT_TO_BITVECTOR */
    1, /* BITVECTOR_TO_NAT */
    2, /* ARRAY_TYPE */
    2, /* SELECT */
    3, /* STORE */
    0, /* STORE_ALL */
    4, /* ARR_TABLE_FUN */
    1, /* ARRAY_LAMBDA */
    MAX_CHILDREN, /* CONSTRUCTOR_TYPE */
    2, /* SELECTOR_TYPE */
    1, /* TESTER_TYPE */
    MAX_CHILDREN, /* APPLY_CONSTRUCTOR */
    1, /* APPLY_SELECTOR */
    1, /* APPLY_SELECTOR_TOTAL */
    1, /* APPLY_TESTER */
    0, /* DATATYPE_TYPE */
    MAX_CHILDREN, /* PARAMETRIC_DATATYPE */
    1, /* APPLY_TYPE_ASCRIPTION */
    0, /* ASCRIPTION_TYPE */
    MAX_CHILDREN, /* TUPLE_TYPE */
    MAX_CHILDREN, /* TUPLE */
    0, /* TUPLE_SELECT_OP */
    1, /* TUPLE_SELECT */
    0, /* TUPLE_UPDATE_OP */
    2, /* TUPLE_UPDATE */
    0, /* RECORD_TYPE */
    MAX_CHILDREN, /* RECORD */
    0, /* RECORD_SELECT_OP */
    1, /* RECORD_SELECT */
    0, /* RECORD_UPDATE_OP */
    2, /* RECORD_UPDATE */
    0, /* EMPTYSET */
    1, /* SET_TYPE */
    2, /* UNION */
    2, /* INTERSECTION */
    2, /* SETMINUS */
    2, /* SUBSET */
    2, /* MEMBER */
    1, /* SINGLETON */
    MAX_CHILDREN, /* INSERT */
    MAX_CHILDREN, /* STRING_CONCAT */
    2, /* STRING_IN_REGEXP */
    1, /* STRING_LENGTH */
    3, /* STRING_SUBSTR */
    3, /* STRING_SUBSTR_TOTAL */
    2, /* STRING_CHARAT */
    2, /* STRING_STRCTN */
    3, /* STRING_STRIDOF */
    3, /* STRING_STRREPL */
    2, /* STRING_PREFIX */
    2, /* STRING_SUFFIX */
    1, /* STRING_ITOS */
    1, /* STRING_STOI */
    1, /* STRING_U16TOS */
    1, /* STRING_STOU16 */
    1, /* STRING_U32TOS */
    1, /* STRING_STOU32 */
    0, /* CONST_STRING */
    0, /* CONST_REGEXP */
    1, /* STRING_TO_REGEXP */
    MAX_CHILDREN, /* REGEXP_CONCAT */
    MAX_CHILDREN, /* REGEXP_UNION */
    MAX_CHILDREN, /* REGEXP_INTER */
    1, /* REGEXP_STAR */
    1, /* REGEXP_PLUS */
    1, /* REGEXP_OPT */
    2, /* REGEXP_RANGE */
    3, /* REGEXP_LOOP */
    0, /* REGEXP_EMPTY */
    0, /* REGEXP_SIGMA */
    3, /* FORALL */
    3, /* EXISTS */
    0, /* INST_CONSTANT */
    MAX_CHILDREN, /* BOUND_VAR_LIST */
    MAX_CHILDREN, /* INST_PATTERN */
    MAX_CHILDREN, /* INST_PATTERN_LIST */
    3, /* REWRITE_RULE */
    3, /* RR_REWRITE */
    3, /* RR_REDUCTION */
    3, /* RR_DEDUCTION */

    0, /* LAST_KIND */
  };

  return ubs[k];
}

}/* CVC4::kind::metakind namespace */

/**
 * Map a kind of the operator to the kind of the enclosing expression. For
 * example, since the kind of functions is just VARIABLE, it should map
 * VARIABLE to APPLY_UF.
 */
static inline Kind operatorToKind(::CVC4::expr::NodeValue* nv) {
  if(nv->getKind() == kind::BUILTIN) {
    return nv->getConst<Kind>();
  } else if(nv->getKind() == kind::LAMBDA) {
    return kind::APPLY_UF;
  }

  switch(Kind k CVC4_UNUSED = nv->getKind()) {


    /* from builtin */
#line 258 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    case kind::SORT_TAG: return kind::SORT_TYPE;
#line 294 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    case kind::FUNCTION: return kind::APPLY;
#line 308 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds"
    case kind::CHAIN_OP: return kind::CHAIN;

    /* from booleans */

    /* from uf */
#line 14 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/uf/kinds"
    case kind::VARIABLE: return kind::APPLY_UF;

    /* from arith */
#line 26 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds"
    case kind::DIVISIBLE_OP: return kind::DIVISIBLE;

    /* from bv */
#line 119 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    case kind::BITVECTOR_BITOF_OP: return kind::BITVECTOR_BITOF;
#line 120 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    case kind::BITVECTOR_EXTRACT_OP: return kind::BITVECTOR_EXTRACT;
#line 121 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    case kind::BITVECTOR_REPEAT_OP: return kind::BITVECTOR_REPEAT;
#line 122 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    case kind::BITVECTOR_ZERO_EXTEND_OP: return kind::BITVECTOR_ZERO_EXTEND;
#line 123 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    case kind::BITVECTOR_SIGN_EXTEND_OP: return kind::BITVECTOR_SIGN_EXTEND;
#line 124 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    case kind::BITVECTOR_ROTATE_LEFT_OP: return kind::BITVECTOR_ROTATE_LEFT;
#line 125 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    case kind::BITVECTOR_ROTATE_RIGHT_OP: return kind::BITVECTOR_ROTATE_RIGHT;
#line 132 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds"
    case kind::INT_TO_BITVECTOR_OP: return kind::INT_TO_BITVECTOR;

    /* from arrays */

    /* from datatypes */
#line 38 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::APPLY_TYPE_ASCRIPTION: return kind::APPLY_CONSTRUCTOR;
#line 40 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::SELECTOR_TYPE: return kind::APPLY_SELECTOR;
#line 43 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::TESTER_TYPE: return kind::APPLY_TESTER;
#line 75 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::ASCRIPTION_TYPE: return kind::APPLY_TYPE_ASCRIPTION;
#line 113 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::TUPLE_SELECT_OP: return kind::TUPLE_SELECT;
#line 121 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::TUPLE_UPDATE_OP: return kind::TUPLE_UPDATE;
#line 140 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::RECORD_TYPE: return kind::RECORD;
#line 149 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::RECORD_SELECT_OP: return kind::RECORD_SELECT;
#line 157 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds"
    case kind::RECORD_UPDATE_OP: return kind::RECORD_UPDATE;

    /* from sets */

    /* from strings */

    /* from quantifiers */

    /* from idl */

  default:
    return kind::UNDEFINED_KIND;  /* LAST_KIND */
  };
}

}/* CVC4::kind namespace */

#line 349 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/metakind_template.h"

namespace theory {

static inline bool useTheoryValidate(std::string theory) {

  if(theory == "idl") {
    return true;
  }
  return false;
}

static const char *const useTheoryHelp = "\
The following options are valid alternate implementations for use with\n\
the --use-theory option:\n\
\n\
idl - alternate implementation for THEORY_ARITH\n\
";

}/* CVC4::theory namespace */
}/* CVC4 namespace */

#endif /* __CVC4__NODE_MANAGER_NEEDS_CONSTANT_MAP */
