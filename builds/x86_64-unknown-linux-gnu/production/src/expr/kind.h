/*********************                                                        */
/** kind.h
 **
 ** Copyright 2010-2014  New York University and The University of Iowa,
 ** and as below.
 **
 ** This header file automatically generated by:
 **
 **     /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/mkkind /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/builtin/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/booleans/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/uf/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arith/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/bv/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/arrays/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/datatypes/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/sets/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/strings/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/quantifiers/kinds /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/theory/idl/kinds
 **
 ** for the CVC4 project.
 **/

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* /home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h */

/*********************                                                        */
/*! \file kind_template.h
 ** \verbatim
 ** Original author: Morgan Deters
 ** Major contributors: Dejan Jovanovic
 ** Minor contributors (to current version): none
 ** This file is part of the CVC4 project.
 ** Copyright (c) 2009-2014  New York University and The University of Iowa
 ** See the file COPYING in the top-level source directory for licensing
 ** information.\endverbatim
 **
 ** \brief Template for the Node kind header
 **
 ** Template for the Node kind header.
 **/

#include "cvc4_public.h"

#ifndef __CVC4__KIND_H
#define __CVC4__KIND_H

#include <iostream>
#include <sstream>

#include "util/exception.h"

namespace CVC4 {
namespace kind {

enum CVC4_PUBLIC Kind_t {
  UNDEFINED_KIND = -1, /**< undefined */
  NULL_EXPR, /**< Null kind */

  /* from builtin */
  SORT_TAG, /**< sort tag (1) */
  SORT_TYPE, /**< specifies types of user-declared 'uninterpreted' sorts (2) */
  UNINTERPRETED_CONSTANT, /**< the kind of expressions representing uninterpreted constants; payload is an instance of the CVC4::UninterpretedConstant class (used in models) (3) */
  ABSTRACT_VALUE, /**< the kind of expressions representing abstract values (other than uninterpreted sort constants); payload is an instance of the CVC4::AbstractValue class (used in models) (4) */
  BUILTIN, /**< the kind of expressions representing built-in operators (5) */
  FUNCTION, /**< a defined function (6) */
  APPLY, /**< application of a defined function (7) */
  EQUAL, /**< equality (two parameters only, sorts must match) (8) */
  DISTINCT, /**< disequality (N-ary, sorts must match) (9) */
  VARIABLE, /**< a variable (not permitted in bindings) (10) */
  BOUND_VARIABLE, /**< a bound variable (permitted in bindings and the associated lambda and quantifier bodies only) (11) */
  SKOLEM, /**< a Skolem variable (internal only) (12) */
  SEXPR, /**< a symbolic expression (any arity) (13) */
  LAMBDA, /**< a lambda expression; first parameter is a BOUND_VAR_LIST, second is lambda body (14) */
  CHAIN, /**< chained operator (N-ary), turned into a conjuction of binary applications of the operator on adjoining parameters; first parameter is a CHAIN_OP representing a binary operator, rest are arguments to that operator (15) */
  CHAIN_OP, /**< the chained operator; payload is an instance of the CVC4::Chain class (16) */
  TYPE_CONSTANT, /**< a representation for basic types (17) */
  FUNCTION_TYPE, /**< a function type (18) */
  SEXPR_TYPE, /**< the type of a symbolic expression (19) */
  SUBTYPE_TYPE, /**< predicate subtype; payload is an instance of the CVC4::Predicate class (20) */

  /* from booleans */
  CONST_BOOLEAN, /**< truth and falsity; payload is a (C++) bool (21) */
  NOT, /**< logical not (22) */
  AND, /**< logical and (N-ary) (23) */
  IFF, /**< logical equivalence (exactly two parameters) (24) */
  IMPLIES, /**< logical implication (exactly two parameters) (25) */
  OR, /**< logical or (N-ary) (26) */
  XOR, /**< exclusive or (exactly two parameters) (27) */
  ITE, /**< if-then-else, used for both Boolean and term ITE constructs; first parameter is (Boolean-sorted) condition, second is 'then', third is 'else' and these two parameters must have same base sort (28) */

  /* from uf */
  APPLY_UF, /**< application of an uninterpreted function; first parameter is the function, remaining ones are parameters to that function (29) */
  CARDINALITY_CONSTRAINT, /**< cardinality constraint on sort S: first parameter is (any) term of sort S, second is a positive integer constant k that bounds the cardinality of S (30) */
  COMBINED_CARDINALITY_CONSTRAINT, /**< combined cardinality constraint; parameter is a positive integer constant k that bounds the sum of the cardinalities of all sorts in the signature (31) */

  /* from arith */
  PLUS, /**< arithmetic addition (N-ary) (32) */
  MULT, /**< arithmetic multiplication (N-ary) (33) */
  MINUS, /**< arithmetic binary subtraction operator (34) */
  UMINUS, /**< arithmetic unary negation (35) */
  DIVISION, /**< real division, division by 0 undefined (user symbol) (36) */
  DIVISION_TOTAL, /**< real division with interpreted division by 0 (internal symbol) (37) */
  INTS_DIVISION, /**< integer division, division by 0 undefined (user symbol) (38) */
  INTS_DIVISION_TOTAL, /**< integer division with interpreted division by 0 (internal symbol) (39) */
  INTS_MODULUS, /**< integer modulus, division by 0 undefined (user symbol) (40) */
  INTS_MODULUS_TOTAL, /**< integer modulus with interpreted division by 0 (internal symbol) (41) */
  ABS, /**< absolute value (42) */
  DIVISIBLE, /**< divisibility-by-k predicate; first parameter is a DIVISIBLE_OP, second is integer term (43) */
  POW, /**< arithmetic power (44) */
  DIVISIBLE_OP, /**< operator for the divisibility-by-k predicate; payload is an instance of the CVC4::Divisible class (45) */
  SUBRANGE_TYPE, /**< the type of an integer subrange (46) */
  CONST_RATIONAL, /**< a multiple-precision rational constant; payload is an instance of the CVC4::Rational class (47) */
  LT, /**< less than, x < y (48) */
  LEQ, /**< less than or equal, x <= y (49) */
  GT, /**< greater than, x > y (50) */
  GEQ, /**< greater than or equal, x >= y (51) */
  IS_INTEGER, /**< term-is-integer predicate (parameter is a real-sorted term) (52) */
  TO_INTEGER, /**< convert term to integer by the floor function (parameter is a real-sorted term) (53) */
  TO_REAL, /**< cast term to real (parameter is an integer-sorted term; this is a no-op in CVC4, as integer is a subtype of real) (54) */

  /* from bv */
  BITVECTOR_TYPE, /**< bit-vector type (55) */
  CONST_BITVECTOR, /**< a fixed-width bit-vector constant; payload is an instance of the CVC4::BitVector class (56) */
  BITVECTOR_CONCAT, /**< concatenation of two or more bit-vectors (57) */
  BITVECTOR_AND, /**< bitwise and of two or more bit-vectors (58) */
  BITVECTOR_OR, /**< bitwise or of two or more bit-vectors (59) */
  BITVECTOR_XOR, /**< bitwise xor of two or more bit-vectors (60) */
  BITVECTOR_NOT, /**< bitwise not of a bit-vector (61) */
  BITVECTOR_NAND, /**< bitwise nand of two bit-vectors (62) */
  BITVECTOR_NOR, /**< bitwise nor of two bit-vectors (63) */
  BITVECTOR_XNOR, /**< bitwise xnor of two bit-vectors (64) */
  BITVECTOR_COMP, /**< equality comparison of two bit-vectors (returns one bit) (65) */
  BITVECTOR_MULT, /**< multiplication of two or more bit-vectors (66) */
  BITVECTOR_PLUS, /**< addition of two or more bit-vectors (67) */
  BITVECTOR_SUB, /**< subtraction of two bit-vectors (68) */
  BITVECTOR_NEG, /**< unary negation of a bit-vector (69) */
  BITVECTOR_UDIV, /**< unsigned division of two bit-vectors, truncating towards 0 (undefined if divisor is 0) (70) */
  BITVECTOR_UREM, /**< unsigned remainder from truncating division of two bit-vectors (undefined if divisor is 0) (71) */
  BITVECTOR_SDIV, /**< 2's complement signed division (72) */
  BITVECTOR_SREM, /**< 2's complement signed remainder (sign follows dividend) (73) */
  BITVECTOR_SMOD, /**< 2's complement signed remainder (sign follows divisor) (74) */
  BITVECTOR_UDIV_TOTAL, /**< unsigned division of two bit-vectors, truncating towards 0 (defined to be the all-ones bit pattern, if divisor is 0) (75) */
  BITVECTOR_UREM_TOTAL, /**< unsigned remainder from truncating division of two bit-vectors (defined to be equal to the dividend, if divisor is 0) (76) */
  BITVECTOR_SHL, /**< bit-vector shift left (the two bit-vector parameters must have same width) (77) */
  BITVECTOR_LSHR, /**< bit-vector logical shift right (the two bit-vector parameters must have same width) (78) */
  BITVECTOR_ASHR, /**< bit-vector arithmetic shift right (the two bit-vector parameters must have same width) (79) */
  BITVECTOR_ULT, /**< bit-vector unsigned less than (the two bit-vector parameters must have same width) (80) */
  BITVECTOR_ULE, /**< bit-vector unsigned less than or equal (the two bit-vector parameters must have same width) (81) */
  BITVECTOR_UGT, /**< bit-vector unsigned greater than (the two bit-vector parameters must have same width) (82) */
  BITVECTOR_UGE, /**< bit-vector unsigned greater than or equal (the two bit-vector parameters must have same width) (83) */
  BITVECTOR_SLT, /**< bit-vector signed less than (the two bit-vector parameters must have same width) (84) */
  BITVECTOR_SLE, /**< bit-vector signed less than or equal (the two bit-vector parameters must have same width) (85) */
  BITVECTOR_SGT, /**< bit-vector signed greater than (the two bit-vector parameters must have same width) (86) */
  BITVECTOR_SGE, /**< bit-vector signed greater than or equal (the two bit-vector parameters must have same width) (87) */
  BITVECTOR_EAGER_ATOM, /**< formula to be treated as a bv atom via eager bit-blasting (internal-only symbol) (88) */
  BITVECTOR_ACKERMANIZE_UDIV, /**< term to be treated as a variable; used for eager bit-blasting Ackermann expansion of bvudiv (internal-only symbol) (89) */
  BITVECTOR_ACKERMANIZE_UREM, /**< term to be treated as a variable; used for eager bit-blasting Ackermann expansion of bvurem (internal-only symbol) (90) */
  BITVECTOR_BITOF_OP, /**< operator for the bit-vector boolean bit extract; payload is an instance of the CVC4::BitVectorBitOf class (91) */
  BITVECTOR_EXTRACT_OP, /**< operator for the bit-vector extract; payload is an instance of the CVC4::BitVectorExtract class (92) */
  BITVECTOR_REPEAT_OP, /**< operator for the bit-vector repeat; payload is an instance of the CVC4::BitVectorRepeat class (93) */
  BITVECTOR_ZERO_EXTEND_OP, /**< operator for the bit-vector zero-extend; payload is an instance of the CVC4::BitVectorZeroExtend class (94) */
  BITVECTOR_SIGN_EXTEND_OP, /**< operator for the bit-vector sign-extend; payload is an instance of the CVC4::BitVectorSignExtend class (95) */
  BITVECTOR_ROTATE_LEFT_OP, /**< operator for the bit-vector rotate left; payload is an instance of the CVC4::BitVectorRotateLeft class (96) */
  BITVECTOR_ROTATE_RIGHT_OP, /**< operator for the bit-vector rotate right; payload is an instance of the CVC4::BitVectorRotateRight class (97) */
  BITVECTOR_BITOF, /**< bit-vector boolean bit extract; first parameter is a BITVECTOR_BITOF_OP, second is a bit-vector term (98) */
  BITVECTOR_EXTRACT, /**< bit-vector extract; first parameter is a BITVECTOR_EXTRACT_OP, second is a bit-vector term (99) */
  BITVECTOR_REPEAT, /**< bit-vector repeat; first parameter is a BITVECTOR_REPEAT_OP, second is a bit-vector term (100) */
  BITVECTOR_ZERO_EXTEND, /**< bit-vector zero-extend; first parameter is a BITVECTOR_ZERO_EXTEND_OP, second is a bit-vector term (101) */
  BITVECTOR_SIGN_EXTEND, /**< bit-vector sign-extend; first parameter is a BITVECTOR_SIGN_EXTEND_OP, second is a bit-vector term (102) */
  BITVECTOR_ROTATE_LEFT, /**< bit-vector rotate left; first parameter is a BITVECTOR_ROTATE_LEFT_OP, second is a bit-vector term (103) */
  BITVECTOR_ROTATE_RIGHT, /**< bit-vector rotate right; first parameter is a BITVECTOR_ROTATE_RIGHT_OP, second is a bit-vector term (104) */
  INT_TO_BITVECTOR_OP, /**< operator for the integer conversion to bit-vector; payload is an instance of the CVC4::IntToBitVector class (105) */
  INT_TO_BITVECTOR, /**< integer conversion to bit-vector; first parameter is an INT_TO_BITVECTOR_OP, second is an integer term (106) */
  BITVECTOR_TO_NAT, /**< bit-vector conversion to (nonnegative) integer; parameter is a bit-vector (107) */

  /* from arrays */
  ARRAY_TYPE, /**< array type (108) */
  SELECT, /**< array select; first parameter is an array term, second is the selection index (109) */
  STORE, /**< array store; first parameter is an array term, second is the store index, third is the term to store at the index (110) */
  STORE_ALL, /**< array store-all; payload is an instance of the CVC4::ArrayStoreAll class (this is not supported by arrays decision procedure yet, but it is used for returned array models) (111) */
  ARR_TABLE_FUN, /**< array table function (internal-only symbol) (112) */
  ARRAY_LAMBDA, /**< array lambda (internal-only symbol) (113) */

  /* from datatypes */
  CONSTRUCTOR_TYPE, /**< constructor (114) */
  SELECTOR_TYPE, /**< selector (115) */
  TESTER_TYPE, /**< tester (116) */
  APPLY_CONSTRUCTOR, /**< constructor application; first parameter is the constructor, remaining parameters (if any) are parameters to the constructor (117) */
  APPLY_SELECTOR, /**< selector application; parameter is a datatype term (undefined if mis-applied) (118) */
  APPLY_SELECTOR_TOTAL, /**< selector application; parameter is a datatype term (defined rigidly if mis-applied) (119) */
  APPLY_TESTER, /**< tester application; first parameter is a tester, second is a datatype term (120) */
  DATATYPE_TYPE, /**< a datatype type (121) */
  PARAMETRIC_DATATYPE, /**< parametric datatype (122) */
  APPLY_TYPE_ASCRIPTION, /**< type ascription, for datatype constructor applications; first parameter is an ASCRIPTION_TYPE, second is the datatype constructor application being ascribed (123) */
  ASCRIPTION_TYPE, /**< a type parameter for type ascription; payload is an instance of the CVC4::AscriptionType class (124) */
  TUPLE_TYPE, /**< tuple type (125) */
  TUPLE, /**< a tuple (N-ary) (126) */
  TUPLE_SELECT_OP, /**< operator for a tuple select; payload is an instance of the CVC4::TupleSelect class (127) */
  TUPLE_SELECT, /**< tuple select; first parameter is a TUPLE_SELECT_OP, second is the tuple (128) */
  TUPLE_UPDATE_OP, /**< operator for a tuple update; payload is an instance of the CVC4::TupleUpdate class (129) */
  TUPLE_UPDATE, /**< tuple update; first parameter is a TUPLE_UPDATE_OP (which references an index), second is the tuple, third is the element to store in the tuple at the given index (130) */
  RECORD_TYPE, /**< record type (131) */
  RECORD, /**< a record; first parameter is a RECORD_TYPE; remaining parameters (if any) are the individual values for fields, in order (132) */
  RECORD_SELECT_OP, /**< operator for a record select; payload is an instance CVC4::RecordSelect class (133) */
  RECORD_SELECT, /**< record select; first parameter is a RECORD_SELECT_OP, second is a record term to select from (134) */
  RECORD_UPDATE_OP, /**< operator for a record update; payload is an instance CVC4::RecordSelect class (135) */
  RECORD_UPDATE, /**< record update; first parameter is a RECORD_UPDATE_OP (which references a field), second is a record term to update, third is the element to store in the record in the given field (136) */

  /* from sets */
  EMPTYSET, /**< the empty set constant; payload is an instance of the CVC4::EmptySet class (137) */
  SET_TYPE, /**< set type, takes as parameter the type of the elements (138) */
  UNION, /**< set union (139) */
  INTERSECTION, /**< set intersection (140) */
  SETMINUS, /**< set subtraction (141) */
  SUBSET, /**< subset predicate; first parameter a subset of second (142) */
  MEMBER, /**< set membership predicate; first parameter a member of second (143) */
  SINGLETON, /**< the set of the single element given as a parameter (144) */
  INSERT, /**< set obtained by inserting elements (first N-1 parameters) into a set (the last parameter) (145) */

  /* from strings */
  STRING_CONCAT, /**< string concat (N-ary) (146) */
  STRING_IN_REGEXP, /**< membership (147) */
  STRING_LENGTH, /**< string length (148) */
  STRING_SUBSTR, /**< string substr (user symbol) (149) */
  STRING_SUBSTR_TOTAL, /**< string substr (internal symbol) (150) */
  STRING_CHARAT, /**< string charat (user symbol) (151) */
  STRING_STRCTN, /**< string contains (152) */
  STRING_STRIDOF, /**< string indexof (153) */
  STRING_STRREPL, /**< string replace (154) */
  STRING_PREFIX, /**< string prefixof (155) */
  STRING_SUFFIX, /**< string suffixof (156) */
  STRING_ITOS, /**< integer to string (157) */
  STRING_STOI, /**< string to integer (total function) (158) */
  STRING_U16TOS, /**< uint16 to string (159) */
  STRING_STOU16, /**< string to uint16 (160) */
  STRING_U32TOS, /**< uint32 to string (161) */
  STRING_STOU32, /**< string to uint32 (162) */
  CONST_STRING, /**< a string of characters (163) */
  CONST_REGEXP, /**< a regular expression (164) */
  STRING_TO_REGEXP, /**< convert string to regexp (165) */
  REGEXP_CONCAT, /**< regexp concat (166) */
  REGEXP_UNION, /**< regexp union (167) */
  REGEXP_INTER, /**< regexp intersection (168) */
  REGEXP_STAR, /**< regexp * (169) */
  REGEXP_PLUS, /**< regexp + (170) */
  REGEXP_OPT, /**< regexp ? (171) */
  REGEXP_RANGE, /**< regexp range (172) */
  REGEXP_LOOP, /**< regexp loop (173) */
  REGEXP_EMPTY, /**< regexp empty (174) */
  REGEXP_SIGMA, /**< regexp all characters (175) */

  /* from quantifiers */
  FORALL, /**< universally quantified formula; first parameter is an BOUND_VAR_LIST, second is quantifier body, and an optional third parameter is an INST_PATTERN_LIST (176) */
  EXISTS, /**< existentially quantified formula; first parameter is an BOUND_VAR_LIST, second is quantifier body, and an optional third parameter is an INST_PATTERN_LIST (177) */
  INST_CONSTANT, /**< instantiation constant (178) */
  BOUND_VAR_LIST, /**< a list of bound variables (used to bind variables under a quantifier) (179) */
  INST_PATTERN, /**< instantiation pattern (180) */
  INST_PATTERN_LIST, /**< a list of instantiation patterns (181) */
  REWRITE_RULE, /**< general rewrite rule (for rewrite-rules theory) (182) */
  RR_REWRITE, /**< actual rewrite rule (for rewrite-rules theory) (183) */
  RR_REDUCTION, /**< actual reduction rule (for rewrite-rules theory) (184) */
  RR_DEDUCTION, /**< actual deduction rule (for rewrite-rules theory) (185) */

  /* from idl */

  LAST_KIND /**< marks the upper-bound of this enumeration */

};/* enum Kind_t */

}/* CVC4::kind namespace */

// import Kind into the "CVC4" namespace but keep the individual kind
// constants under kind::
typedef ::CVC4::kind::Kind_t Kind;

namespace kind {

inline std::ostream& operator<<(std::ostream&, CVC4::Kind) CVC4_PUBLIC;
inline std::ostream& operator<<(std::ostream& out, CVC4::Kind k) {
  using namespace CVC4::kind;

  switch(k) {

  /* special cases */
  case UNDEFINED_KIND: out << "UNDEFINED_KIND"; break;
  case NULL_EXPR: out << "NULL"; break;

  /* from builtin */
  case SORT_TAG: out << "SORT_TAG"; break;
  case SORT_TYPE: out << "SORT_TYPE"; break;
  case UNINTERPRETED_CONSTANT: out << "UNINTERPRETED_CONSTANT"; break;
  case ABSTRACT_VALUE: out << "ABSTRACT_VALUE"; break;
  case BUILTIN: out << "BUILTIN"; break;
  case FUNCTION: out << "FUNCTION"; break;
  case APPLY: out << "APPLY"; break;
  case EQUAL: out << "EQUAL"; break;
  case DISTINCT: out << "DISTINCT"; break;
  case VARIABLE: out << "VARIABLE"; break;
  case BOUND_VARIABLE: out << "BOUND_VARIABLE"; break;
  case SKOLEM: out << "SKOLEM"; break;
  case SEXPR: out << "SEXPR"; break;
  case LAMBDA: out << "LAMBDA"; break;
  case CHAIN: out << "CHAIN"; break;
  case CHAIN_OP: out << "CHAIN_OP"; break;
  case TYPE_CONSTANT: out << "TYPE_CONSTANT"; break;
  case FUNCTION_TYPE: out << "FUNCTION_TYPE"; break;
  case SEXPR_TYPE: out << "SEXPR_TYPE"; break;
  case SUBTYPE_TYPE: out << "SUBTYPE_TYPE"; break;

  /* from booleans */
  case CONST_BOOLEAN: out << "CONST_BOOLEAN"; break;
  case NOT: out << "NOT"; break;
  case AND: out << "AND"; break;
  case IFF: out << "IFF"; break;
  case IMPLIES: out << "IMPLIES"; break;
  case OR: out << "OR"; break;
  case XOR: out << "XOR"; break;
  case ITE: out << "ITE"; break;

  /* from uf */
  case APPLY_UF: out << "APPLY_UF"; break;
  case CARDINALITY_CONSTRAINT: out << "CARDINALITY_CONSTRAINT"; break;
  case COMBINED_CARDINALITY_CONSTRAINT: out << "COMBINED_CARDINALITY_CONSTRAINT"; break;

  /* from arith */
  case PLUS: out << "PLUS"; break;
  case MULT: out << "MULT"; break;
  case MINUS: out << "MINUS"; break;
  case UMINUS: out << "UMINUS"; break;
  case DIVISION: out << "DIVISION"; break;
  case DIVISION_TOTAL: out << "DIVISION_TOTAL"; break;
  case INTS_DIVISION: out << "INTS_DIVISION"; break;
  case INTS_DIVISION_TOTAL: out << "INTS_DIVISION_TOTAL"; break;
  case INTS_MODULUS: out << "INTS_MODULUS"; break;
  case INTS_MODULUS_TOTAL: out << "INTS_MODULUS_TOTAL"; break;
  case ABS: out << "ABS"; break;
  case DIVISIBLE: out << "DIVISIBLE"; break;
  case POW: out << "POW"; break;
  case DIVISIBLE_OP: out << "DIVISIBLE_OP"; break;
  case SUBRANGE_TYPE: out << "SUBRANGE_TYPE"; break;
  case CONST_RATIONAL: out << "CONST_RATIONAL"; break;
  case LT: out << "LT"; break;
  case LEQ: out << "LEQ"; break;
  case GT: out << "GT"; break;
  case GEQ: out << "GEQ"; break;
  case IS_INTEGER: out << "IS_INTEGER"; break;
  case TO_INTEGER: out << "TO_INTEGER"; break;
  case TO_REAL: out << "TO_REAL"; break;

  /* from bv */
  case BITVECTOR_TYPE: out << "BITVECTOR_TYPE"; break;
  case CONST_BITVECTOR: out << "CONST_BITVECTOR"; break;
  case BITVECTOR_CONCAT: out << "BITVECTOR_CONCAT"; break;
  case BITVECTOR_AND: out << "BITVECTOR_AND"; break;
  case BITVECTOR_OR: out << "BITVECTOR_OR"; break;
  case BITVECTOR_XOR: out << "BITVECTOR_XOR"; break;
  case BITVECTOR_NOT: out << "BITVECTOR_NOT"; break;
  case BITVECTOR_NAND: out << "BITVECTOR_NAND"; break;
  case BITVECTOR_NOR: out << "BITVECTOR_NOR"; break;
  case BITVECTOR_XNOR: out << "BITVECTOR_XNOR"; break;
  case BITVECTOR_COMP: out << "BITVECTOR_COMP"; break;
  case BITVECTOR_MULT: out << "BITVECTOR_MULT"; break;
  case BITVECTOR_PLUS: out << "BITVECTOR_PLUS"; break;
  case BITVECTOR_SUB: out << "BITVECTOR_SUB"; break;
  case BITVECTOR_NEG: out << "BITVECTOR_NEG"; break;
  case BITVECTOR_UDIV: out << "BITVECTOR_UDIV"; break;
  case BITVECTOR_UREM: out << "BITVECTOR_UREM"; break;
  case BITVECTOR_SDIV: out << "BITVECTOR_SDIV"; break;
  case BITVECTOR_SREM: out << "BITVECTOR_SREM"; break;
  case BITVECTOR_SMOD: out << "BITVECTOR_SMOD"; break;
  case BITVECTOR_UDIV_TOTAL: out << "BITVECTOR_UDIV_TOTAL"; break;
  case BITVECTOR_UREM_TOTAL: out << "BITVECTOR_UREM_TOTAL"; break;
  case BITVECTOR_SHL: out << "BITVECTOR_SHL"; break;
  case BITVECTOR_LSHR: out << "BITVECTOR_LSHR"; break;
  case BITVECTOR_ASHR: out << "BITVECTOR_ASHR"; break;
  case BITVECTOR_ULT: out << "BITVECTOR_ULT"; break;
  case BITVECTOR_ULE: out << "BITVECTOR_ULE"; break;
  case BITVECTOR_UGT: out << "BITVECTOR_UGT"; break;
  case BITVECTOR_UGE: out << "BITVECTOR_UGE"; break;
  case BITVECTOR_SLT: out << "BITVECTOR_SLT"; break;
  case BITVECTOR_SLE: out << "BITVECTOR_SLE"; break;
  case BITVECTOR_SGT: out << "BITVECTOR_SGT"; break;
  case BITVECTOR_SGE: out << "BITVECTOR_SGE"; break;
  case BITVECTOR_EAGER_ATOM: out << "BITVECTOR_EAGER_ATOM"; break;
  case BITVECTOR_ACKERMANIZE_UDIV: out << "BITVECTOR_ACKERMANIZE_UDIV"; break;
  case BITVECTOR_ACKERMANIZE_UREM: out << "BITVECTOR_ACKERMANIZE_UREM"; break;
  case BITVECTOR_BITOF_OP: out << "BITVECTOR_BITOF_OP"; break;
  case BITVECTOR_EXTRACT_OP: out << "BITVECTOR_EXTRACT_OP"; break;
  case BITVECTOR_REPEAT_OP: out << "BITVECTOR_REPEAT_OP"; break;
  case BITVECTOR_ZERO_EXTEND_OP: out << "BITVECTOR_ZERO_EXTEND_OP"; break;
  case BITVECTOR_SIGN_EXTEND_OP: out << "BITVECTOR_SIGN_EXTEND_OP"; break;
  case BITVECTOR_ROTATE_LEFT_OP: out << "BITVECTOR_ROTATE_LEFT_OP"; break;
  case BITVECTOR_ROTATE_RIGHT_OP: out << "BITVECTOR_ROTATE_RIGHT_OP"; break;
  case BITVECTOR_BITOF: out << "BITVECTOR_BITOF"; break;
  case BITVECTOR_EXTRACT: out << "BITVECTOR_EXTRACT"; break;
  case BITVECTOR_REPEAT: out << "BITVECTOR_REPEAT"; break;
  case BITVECTOR_ZERO_EXTEND: out << "BITVECTOR_ZERO_EXTEND"; break;
  case BITVECTOR_SIGN_EXTEND: out << "BITVECTOR_SIGN_EXTEND"; break;
  case BITVECTOR_ROTATE_LEFT: out << "BITVECTOR_ROTATE_LEFT"; break;
  case BITVECTOR_ROTATE_RIGHT: out << "BITVECTOR_ROTATE_RIGHT"; break;
  case INT_TO_BITVECTOR_OP: out << "INT_TO_BITVECTOR_OP"; break;
  case INT_TO_BITVECTOR: out << "INT_TO_BITVECTOR"; break;
  case BITVECTOR_TO_NAT: out << "BITVECTOR_TO_NAT"; break;

  /* from arrays */
  case ARRAY_TYPE: out << "ARRAY_TYPE"; break;
  case SELECT: out << "SELECT"; break;
  case STORE: out << "STORE"; break;
  case STORE_ALL: out << "STORE_ALL"; break;
  case ARR_TABLE_FUN: out << "ARR_TABLE_FUN"; break;
  case ARRAY_LAMBDA: out << "ARRAY_LAMBDA"; break;

  /* from datatypes */
  case CONSTRUCTOR_TYPE: out << "CONSTRUCTOR_TYPE"; break;
  case SELECTOR_TYPE: out << "SELECTOR_TYPE"; break;
  case TESTER_TYPE: out << "TESTER_TYPE"; break;
  case APPLY_CONSTRUCTOR: out << "APPLY_CONSTRUCTOR"; break;
  case APPLY_SELECTOR: out << "APPLY_SELECTOR"; break;
  case APPLY_SELECTOR_TOTAL: out << "APPLY_SELECTOR_TOTAL"; break;
  case APPLY_TESTER: out << "APPLY_TESTER"; break;
  case DATATYPE_TYPE: out << "DATATYPE_TYPE"; break;
  case PARAMETRIC_DATATYPE: out << "PARAMETRIC_DATATYPE"; break;
  case APPLY_TYPE_ASCRIPTION: out << "APPLY_TYPE_ASCRIPTION"; break;
  case ASCRIPTION_TYPE: out << "ASCRIPTION_TYPE"; break;
  case TUPLE_TYPE: out << "TUPLE_TYPE"; break;
  case TUPLE: out << "TUPLE"; break;
  case TUPLE_SELECT_OP: out << "TUPLE_SELECT_OP"; break;
  case TUPLE_SELECT: out << "TUPLE_SELECT"; break;
  case TUPLE_UPDATE_OP: out << "TUPLE_UPDATE_OP"; break;
  case TUPLE_UPDATE: out << "TUPLE_UPDATE"; break;
  case RECORD_TYPE: out << "RECORD_TYPE"; break;
  case RECORD: out << "RECORD"; break;
  case RECORD_SELECT_OP: out << "RECORD_SELECT_OP"; break;
  case RECORD_SELECT: out << "RECORD_SELECT"; break;
  case RECORD_UPDATE_OP: out << "RECORD_UPDATE_OP"; break;
  case RECORD_UPDATE: out << "RECORD_UPDATE"; break;

  /* from sets */
  case EMPTYSET: out << "EMPTYSET"; break;
  case SET_TYPE: out << "SET_TYPE"; break;
  case UNION: out << "UNION"; break;
  case INTERSECTION: out << "INTERSECTION"; break;
  case SETMINUS: out << "SETMINUS"; break;
  case SUBSET: out << "SUBSET"; break;
  case MEMBER: out << "MEMBER"; break;
  case SINGLETON: out << "SINGLETON"; break;
  case INSERT: out << "INSERT"; break;

  /* from strings */
  case STRING_CONCAT: out << "STRING_CONCAT"; break;
  case STRING_IN_REGEXP: out << "STRING_IN_REGEXP"; break;
  case STRING_LENGTH: out << "STRING_LENGTH"; break;
  case STRING_SUBSTR: out << "STRING_SUBSTR"; break;
  case STRING_SUBSTR_TOTAL: out << "STRING_SUBSTR_TOTAL"; break;
  case STRING_CHARAT: out << "STRING_CHARAT"; break;
  case STRING_STRCTN: out << "STRING_STRCTN"; break;
  case STRING_STRIDOF: out << "STRING_STRIDOF"; break;
  case STRING_STRREPL: out << "STRING_STRREPL"; break;
  case STRING_PREFIX: out << "STRING_PREFIX"; break;
  case STRING_SUFFIX: out << "STRING_SUFFIX"; break;
  case STRING_ITOS: out << "STRING_ITOS"; break;
  case STRING_STOI: out << "STRING_STOI"; break;
  case STRING_U16TOS: out << "STRING_U16TOS"; break;
  case STRING_STOU16: out << "STRING_STOU16"; break;
  case STRING_U32TOS: out << "STRING_U32TOS"; break;
  case STRING_STOU32: out << "STRING_STOU32"; break;
  case CONST_STRING: out << "CONST_STRING"; break;
  case CONST_REGEXP: out << "CONST_REGEXP"; break;
  case STRING_TO_REGEXP: out << "STRING_TO_REGEXP"; break;
  case REGEXP_CONCAT: out << "REGEXP_CONCAT"; break;
  case REGEXP_UNION: out << "REGEXP_UNION"; break;
  case REGEXP_INTER: out << "REGEXP_INTER"; break;
  case REGEXP_STAR: out << "REGEXP_STAR"; break;
  case REGEXP_PLUS: out << "REGEXP_PLUS"; break;
  case REGEXP_OPT: out << "REGEXP_OPT"; break;
  case REGEXP_RANGE: out << "REGEXP_RANGE"; break;
  case REGEXP_LOOP: out << "REGEXP_LOOP"; break;
  case REGEXP_EMPTY: out << "REGEXP_EMPTY"; break;
  case REGEXP_SIGMA: out << "REGEXP_SIGMA"; break;

  /* from quantifiers */
  case FORALL: out << "FORALL"; break;
  case EXISTS: out << "EXISTS"; break;
  case INST_CONSTANT: out << "INST_CONSTANT"; break;
  case BOUND_VAR_LIST: out << "BOUND_VAR_LIST"; break;
  case INST_PATTERN: out << "INST_PATTERN"; break;
  case INST_PATTERN_LIST: out << "INST_PATTERN_LIST"; break;
  case REWRITE_RULE: out << "REWRITE_RULE"; break;
  case RR_REWRITE: out << "RR_REWRITE"; break;
  case RR_REDUCTION: out << "RR_REDUCTION"; break;
  case RR_DEDUCTION: out << "RR_DEDUCTION"; break;

  /* from idl */

  case LAST_KIND: out << "LAST_KIND"; break;
  default: out << "UNKNOWNKIND!" << int(k); break;
  }

  return out;
}

#line 64 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h"

/** Returns true if the given kind is associative. This is used by ExprManager to
 * decide whether it's safe to modify big expressions by changing the grouping of
 * the arguments. */
/* TODO: This could be generated. */
inline bool isAssociative(::CVC4::Kind k) {
  switch(k) {
  case kind::AND:
  case kind::OR:
  case kind::MULT:
  case kind::PLUS:
    return true;

  default:
    return false;
  }
}

inline std::string kindToString(::CVC4::Kind k) {
  std::stringstream ss;
  ss << k;
  return ss.str();
}

struct KindHashFunction {
  inline size_t operator()(::CVC4::Kind k) const {
    return k;
  }
};/* struct KindHashFunction */

}/* CVC4::kind namespace */

/**
 * The enumeration for the built-in atomic types.
 */
enum TypeConstant {
  BUILTIN_OPERATOR_TYPE, /**< the type for built-in operators */
  BOOLEAN_TYPE, /**< Boolean type */
  REAL_TYPE, /**< real type */
  INTEGER_TYPE, /**< integer type */
  STRING_TYPE, /**< String type */
  REGEXP_TYPE, /**< RegExp type */
  BOUND_VAR_LIST_TYPE, /**< the type of bound variable lists */
  INST_PATTERN_TYPE, /**< instantiation pattern type */
  INST_PATTERN_LIST_TYPE, /**< the type of instantiation pattern lists */
  RRHB_TYPE, /**< head and body of the rule type (for rewrite-rules theory) */

#line 102 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h"
  LAST_TYPE
};/* enum TypeConstant */

/**
 * We hash the constants with their values.
 */
struct TypeConstantHashFunction {
  inline size_t operator()(TypeConstant tc) const {
    return tc;
  }
};/* struct TypeConstantHashFunction */

inline std::ostream& operator<<(std::ostream& out, TypeConstant typeConstant) {
  switch(typeConstant) {
  case BUILTIN_OPERATOR_TYPE:  out << "the type for built-in operators"; break;
  case BOOLEAN_TYPE:  out << "Boolean type"; break;
  case REAL_TYPE:  out << "real type"; break;
  case INTEGER_TYPE:  out << "integer type"; break;
  case STRING_TYPE:  out << "String type"; break;
  case REGEXP_TYPE:  out << "RegExp type"; break;
  case BOUND_VAR_LIST_TYPE:  out << "the type of bound variable lists"; break;
  case INST_PATTERN_TYPE:  out << "instantiation pattern type"; break;
  case INST_PATTERN_LIST_TYPE:  out << "the type of instantiation pattern lists"; break;
  case RRHB_TYPE:  out << "head and body of the rule type (for rewrite-rules theory)"; break;

#line 118 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h"
  default:
    out << "UNKNOWN_TYPE_CONSTANT";
    break;
  }
  return out;
}

namespace theory {

enum TheoryId {
  THEORY_BUILTIN,
  THEORY_BOOL,
  THEORY_UF,
  THEORY_ARITH,
  THEORY_BV,
  THEORY_ARRAY,
  THEORY_DATATYPES,
  THEORY_SETS,
  THEORY_STRINGS,
  THEORY_QUANTIFIERS,

#line 130 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h"
  THEORY_LAST
};/* enum TheoryId */

const TheoryId THEORY_FIRST = static_cast<TheoryId>(0);
const TheoryId THEORY_SAT_SOLVER = THEORY_LAST;

inline TheoryId& operator ++ (TheoryId& id) {
  return id = static_cast<TheoryId>(((int)id) + 1);
}

inline std::ostream& operator<<(std::ostream& out, TheoryId theoryId) {
  switch(theoryId) {
  case THEORY_BUILTIN: out << "THEORY_BUILTIN"; break;
  case THEORY_BOOL: out << "THEORY_BOOL"; break;
  case THEORY_UF: out << "THEORY_UF"; break;
  case THEORY_ARITH: out << "THEORY_ARITH"; break;
  case THEORY_BV: out << "THEORY_BV"; break;
  case THEORY_ARRAY: out << "THEORY_ARRAY"; break;
  case THEORY_DATATYPES: out << "THEORY_DATATYPES"; break;
  case THEORY_SETS: out << "THEORY_SETS"; break;
  case THEORY_STRINGS: out << "THEORY_STRINGS"; break;
  case THEORY_QUANTIFIERS: out << "THEORY_QUANTIFIERS"; break;

#line 144 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h"
  default:
    out << "UNKNOWN_THEORY";
    break;
  }
  return out;
}

inline TheoryId kindToTheoryId(::CVC4::Kind k) {
  switch(k) {
  case kind::UNDEFINED_KIND:
  case kind::NULL_EXPR:
    break;
  case kind::SORT_TAG: return THEORY_BUILTIN;
  case kind::SORT_TYPE: return THEORY_BUILTIN;
  case kind::UNINTERPRETED_CONSTANT: return THEORY_BUILTIN;
  case kind::ABSTRACT_VALUE: return THEORY_BUILTIN;
  case kind::BUILTIN: return THEORY_BUILTIN;
  case kind::FUNCTION: return THEORY_BUILTIN;
  case kind::APPLY: return THEORY_BUILTIN;
  case kind::EQUAL: return THEORY_BUILTIN;
  case kind::DISTINCT: return THEORY_BUILTIN;
  case kind::VARIABLE: return THEORY_BUILTIN;
  case kind::BOUND_VARIABLE: return THEORY_BUILTIN;
  case kind::SKOLEM: return THEORY_BUILTIN;
  case kind::SEXPR: return THEORY_BUILTIN;
  case kind::LAMBDA: return THEORY_BUILTIN;
  case kind::CHAIN: return THEORY_BUILTIN;
  case kind::CHAIN_OP: return THEORY_BUILTIN;
  case kind::TYPE_CONSTANT: return THEORY_BUILTIN;
  case kind::FUNCTION_TYPE: return THEORY_BUILTIN;
  case kind::SEXPR_TYPE: return THEORY_BUILTIN;
  case kind::SUBTYPE_TYPE: return THEORY_BUILTIN;
  case kind::CONST_BOOLEAN: return THEORY_BOOL;
  case kind::NOT: return THEORY_BOOL;
  case kind::AND: return THEORY_BOOL;
  case kind::IFF: return THEORY_BOOL;
  case kind::IMPLIES: return THEORY_BOOL;
  case kind::OR: return THEORY_BOOL;
  case kind::XOR: return THEORY_BOOL;
  case kind::ITE: return THEORY_BOOL;
  case kind::APPLY_UF: return THEORY_UF;
  case kind::CARDINALITY_CONSTRAINT: return THEORY_UF;
  case kind::COMBINED_CARDINALITY_CONSTRAINT: return THEORY_UF;
  case kind::PLUS: return THEORY_ARITH;
  case kind::MULT: return THEORY_ARITH;
  case kind::MINUS: return THEORY_ARITH;
  case kind::UMINUS: return THEORY_ARITH;
  case kind::DIVISION: return THEORY_ARITH;
  case kind::DIVISION_TOTAL: return THEORY_ARITH;
  case kind::INTS_DIVISION: return THEORY_ARITH;
  case kind::INTS_DIVISION_TOTAL: return THEORY_ARITH;
  case kind::INTS_MODULUS: return THEORY_ARITH;
  case kind::INTS_MODULUS_TOTAL: return THEORY_ARITH;
  case kind::ABS: return THEORY_ARITH;
  case kind::DIVISIBLE: return THEORY_ARITH;
  case kind::POW: return THEORY_ARITH;
  case kind::DIVISIBLE_OP: return THEORY_ARITH;
  case kind::SUBRANGE_TYPE: return THEORY_ARITH;
  case kind::CONST_RATIONAL: return THEORY_ARITH;
  case kind::LT: return THEORY_ARITH;
  case kind::LEQ: return THEORY_ARITH;
  case kind::GT: return THEORY_ARITH;
  case kind::GEQ: return THEORY_ARITH;
  case kind::IS_INTEGER: return THEORY_ARITH;
  case kind::TO_INTEGER: return THEORY_ARITH;
  case kind::TO_REAL: return THEORY_ARITH;
  case kind::BITVECTOR_TYPE: return THEORY_BV;
  case kind::CONST_BITVECTOR: return THEORY_BV;
  case kind::BITVECTOR_CONCAT: return THEORY_BV;
  case kind::BITVECTOR_AND: return THEORY_BV;
  case kind::BITVECTOR_OR: return THEORY_BV;
  case kind::BITVECTOR_XOR: return THEORY_BV;
  case kind::BITVECTOR_NOT: return THEORY_BV;
  case kind::BITVECTOR_NAND: return THEORY_BV;
  case kind::BITVECTOR_NOR: return THEORY_BV;
  case kind::BITVECTOR_XNOR: return THEORY_BV;
  case kind::BITVECTOR_COMP: return THEORY_BV;
  case kind::BITVECTOR_MULT: return THEORY_BV;
  case kind::BITVECTOR_PLUS: return THEORY_BV;
  case kind::BITVECTOR_SUB: return THEORY_BV;
  case kind::BITVECTOR_NEG: return THEORY_BV;
  case kind::BITVECTOR_UDIV: return THEORY_BV;
  case kind::BITVECTOR_UREM: return THEORY_BV;
  case kind::BITVECTOR_SDIV: return THEORY_BV;
  case kind::BITVECTOR_SREM: return THEORY_BV;
  case kind::BITVECTOR_SMOD: return THEORY_BV;
  case kind::BITVECTOR_UDIV_TOTAL: return THEORY_BV;
  case kind::BITVECTOR_UREM_TOTAL: return THEORY_BV;
  case kind::BITVECTOR_SHL: return THEORY_BV;
  case kind::BITVECTOR_LSHR: return THEORY_BV;
  case kind::BITVECTOR_ASHR: return THEORY_BV;
  case kind::BITVECTOR_ULT: return THEORY_BV;
  case kind::BITVECTOR_ULE: return THEORY_BV;
  case kind::BITVECTOR_UGT: return THEORY_BV;
  case kind::BITVECTOR_UGE: return THEORY_BV;
  case kind::BITVECTOR_SLT: return THEORY_BV;
  case kind::BITVECTOR_SLE: return THEORY_BV;
  case kind::BITVECTOR_SGT: return THEORY_BV;
  case kind::BITVECTOR_SGE: return THEORY_BV;
  case kind::BITVECTOR_EAGER_ATOM: return THEORY_BV;
  case kind::BITVECTOR_ACKERMANIZE_UDIV: return THEORY_BV;
  case kind::BITVECTOR_ACKERMANIZE_UREM: return THEORY_BV;
  case kind::BITVECTOR_BITOF_OP: return THEORY_BV;
  case kind::BITVECTOR_EXTRACT_OP: return THEORY_BV;
  case kind::BITVECTOR_REPEAT_OP: return THEORY_BV;
  case kind::BITVECTOR_ZERO_EXTEND_OP: return THEORY_BV;
  case kind::BITVECTOR_SIGN_EXTEND_OP: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_LEFT_OP: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_RIGHT_OP: return THEORY_BV;
  case kind::BITVECTOR_BITOF: return THEORY_BV;
  case kind::BITVECTOR_EXTRACT: return THEORY_BV;
  case kind::BITVECTOR_REPEAT: return THEORY_BV;
  case kind::BITVECTOR_ZERO_EXTEND: return THEORY_BV;
  case kind::BITVECTOR_SIGN_EXTEND: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_LEFT: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_RIGHT: return THEORY_BV;
  case kind::INT_TO_BITVECTOR_OP: return THEORY_BV;
  case kind::INT_TO_BITVECTOR: return THEORY_BV;
  case kind::BITVECTOR_TO_NAT: return THEORY_BV;
  case kind::ARRAY_TYPE: return THEORY_ARRAY;
  case kind::SELECT: return THEORY_ARRAY;
  case kind::STORE: return THEORY_ARRAY;
  case kind::STORE_ALL: return THEORY_ARRAY;
  case kind::ARR_TABLE_FUN: return THEORY_ARRAY;
  case kind::ARRAY_LAMBDA: return THEORY_ARRAY;
  case kind::CONSTRUCTOR_TYPE: return THEORY_DATATYPES;
  case kind::SELECTOR_TYPE: return THEORY_DATATYPES;
  case kind::TESTER_TYPE: return THEORY_DATATYPES;
  case kind::APPLY_CONSTRUCTOR: return THEORY_DATATYPES;
  case kind::APPLY_SELECTOR: return THEORY_DATATYPES;
  case kind::APPLY_SELECTOR_TOTAL: return THEORY_DATATYPES;
  case kind::APPLY_TESTER: return THEORY_DATATYPES;
  case kind::DATATYPE_TYPE: return THEORY_DATATYPES;
  case kind::PARAMETRIC_DATATYPE: return THEORY_DATATYPES;
  case kind::APPLY_TYPE_ASCRIPTION: return THEORY_DATATYPES;
  case kind::ASCRIPTION_TYPE: return THEORY_DATATYPES;
  case kind::TUPLE_TYPE: return THEORY_DATATYPES;
  case kind::TUPLE: return THEORY_DATATYPES;
  case kind::TUPLE_SELECT_OP: return THEORY_DATATYPES;
  case kind::TUPLE_SELECT: return THEORY_DATATYPES;
  case kind::TUPLE_UPDATE_OP: return THEORY_DATATYPES;
  case kind::TUPLE_UPDATE: return THEORY_DATATYPES;
  case kind::RECORD_TYPE: return THEORY_DATATYPES;
  case kind::RECORD: return THEORY_DATATYPES;
  case kind::RECORD_SELECT_OP: return THEORY_DATATYPES;
  case kind::RECORD_SELECT: return THEORY_DATATYPES;
  case kind::RECORD_UPDATE_OP: return THEORY_DATATYPES;
  case kind::RECORD_UPDATE: return THEORY_DATATYPES;
  case kind::EMPTYSET: return THEORY_SETS;
  case kind::SET_TYPE: return THEORY_SETS;
  case kind::UNION: return THEORY_SETS;
  case kind::INTERSECTION: return THEORY_SETS;
  case kind::SETMINUS: return THEORY_SETS;
  case kind::SUBSET: return THEORY_SETS;
  case kind::MEMBER: return THEORY_SETS;
  case kind::SINGLETON: return THEORY_SETS;
  case kind::INSERT: return THEORY_SETS;
  case kind::STRING_CONCAT: return THEORY_STRINGS;
  case kind::STRING_IN_REGEXP: return THEORY_STRINGS;
  case kind::STRING_LENGTH: return THEORY_STRINGS;
  case kind::STRING_SUBSTR: return THEORY_STRINGS;
  case kind::STRING_SUBSTR_TOTAL: return THEORY_STRINGS;
  case kind::STRING_CHARAT: return THEORY_STRINGS;
  case kind::STRING_STRCTN: return THEORY_STRINGS;
  case kind::STRING_STRIDOF: return THEORY_STRINGS;
  case kind::STRING_STRREPL: return THEORY_STRINGS;
  case kind::STRING_PREFIX: return THEORY_STRINGS;
  case kind::STRING_SUFFIX: return THEORY_STRINGS;
  case kind::STRING_ITOS: return THEORY_STRINGS;
  case kind::STRING_STOI: return THEORY_STRINGS;
  case kind::STRING_U16TOS: return THEORY_STRINGS;
  case kind::STRING_STOU16: return THEORY_STRINGS;
  case kind::STRING_U32TOS: return THEORY_STRINGS;
  case kind::STRING_STOU32: return THEORY_STRINGS;
  case kind::CONST_STRING: return THEORY_STRINGS;
  case kind::CONST_REGEXP: return THEORY_STRINGS;
  case kind::STRING_TO_REGEXP: return THEORY_STRINGS;
  case kind::REGEXP_CONCAT: return THEORY_STRINGS;
  case kind::REGEXP_UNION: return THEORY_STRINGS;
  case kind::REGEXP_INTER: return THEORY_STRINGS;
  case kind::REGEXP_STAR: return THEORY_STRINGS;
  case kind::REGEXP_PLUS: return THEORY_STRINGS;
  case kind::REGEXP_OPT: return THEORY_STRINGS;
  case kind::REGEXP_RANGE: return THEORY_STRINGS;
  case kind::REGEXP_LOOP: return THEORY_STRINGS;
  case kind::REGEXP_EMPTY: return THEORY_STRINGS;
  case kind::REGEXP_SIGMA: return THEORY_STRINGS;
  case kind::FORALL: return THEORY_QUANTIFIERS;
  case kind::EXISTS: return THEORY_QUANTIFIERS;
  case kind::INST_CONSTANT: return THEORY_QUANTIFIERS;
  case kind::BOUND_VAR_LIST: return THEORY_QUANTIFIERS;
  case kind::INST_PATTERN: return THEORY_QUANTIFIERS;
  case kind::INST_PATTERN_LIST: return THEORY_QUANTIFIERS;
  case kind::REWRITE_RULE: return THEORY_QUANTIFIERS;
  case kind::RR_REWRITE: return THEORY_QUANTIFIERS;
  case kind::RR_REDUCTION: return THEORY_QUANTIFIERS;
  case kind::RR_DEDUCTION: return THEORY_QUANTIFIERS;

#line 158 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h"
  case kind::LAST_KIND:
    break;
  }
  throw IllegalArgumentException("", "k", __PRETTY_FUNCTION__, "bad kind");
}

inline TheoryId typeConstantToTheoryId(::CVC4::TypeConstant typeConstant) {
  switch(typeConstant) {
  case BUILTIN_OPERATOR_TYPE: return THEORY_BUILTIN;
  case BOOLEAN_TYPE: return THEORY_BOOL;
  case REAL_TYPE: return THEORY_ARITH;
  case INTEGER_TYPE: return THEORY_ARITH;
  case STRING_TYPE: return THEORY_STRINGS;
  case REGEXP_TYPE: return THEORY_STRINGS;
  case BOUND_VAR_LIST_TYPE: return THEORY_QUANTIFIERS;
  case INST_PATTERN_TYPE: return THEORY_QUANTIFIERS;
  case INST_PATTERN_LIST_TYPE: return THEORY_QUANTIFIERS;
  case RRHB_TYPE: return THEORY_QUANTIFIERS;

#line 168 "/home/lkloh/cvc4-1.4/builds/x86_64-unknown-linux-gnu/production/../../../src/expr/kind_template.h"
  case LAST_TYPE:
    break;
  }
  throw IllegalArgumentException("", "k", __PRETTY_FUNCTION__, "bad type constant");
}

}/* CVC4::theory namespace */
}/* CVC4 namespace */

#endif /* __CVC4__KIND_H */
